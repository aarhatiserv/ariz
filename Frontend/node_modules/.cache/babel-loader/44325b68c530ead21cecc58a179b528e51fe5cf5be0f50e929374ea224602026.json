{"ast":null,"code":"import _regeneratorRuntime from \"E:/Aarhat Iserv - E-commerce/new/ariz/Frontend/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _objectSpread from \"E:/Aarhat Iserv - E-commerce/new/ariz/Frontend/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _asyncToGenerator from \"E:/Aarhat Iserv - E-commerce/new/ariz/Frontend/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nfunction unstable_mapSliceZone(sliceZone, mappers, context) {\n  return Promise.all(sliceZone.map( /*#__PURE__*/function () {\n    var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(slice, index, slices) {\n      var isRestSliceType, sliceType, mapper, mapperArgs, result;\n      return _regeneratorRuntime().wrap(function _callee$(_context) {\n        while (1) switch (_context.prev = _context.next) {\n          case 0:\n            isRestSliceType = \"slice_type\" in slice;\n            sliceType = isRestSliceType ? slice.slice_type : slice.type;\n            mapper = mappers[sliceType];\n            if (mapper) {\n              _context.next = 5;\n              break;\n            }\n            return _context.abrupt(\"return\", slice);\n          case 5:\n            mapperArgs = {\n              slice: slice,\n              slices: slices,\n              index: index,\n              context: context\n            };\n            _context.next = 8;\n            return mapper(mapperArgs);\n          case 8:\n            result = _context.sent;\n            if (!(\n            // `mapper.length < 1` ensures the given\n            // function is something of the form:\n            // `() => import(...)`\n            mapper.length < 1 && (typeof result === \"function\" || typeof result === \"object\" && \"default\" in result))) {\n              _context.next = 14;\n              break;\n            }\n            result = \"default\" in result ? result.default : result;\n            _context.next = 13;\n            return result(mapperArgs);\n          case 13:\n            result = _context.sent;\n          case 14:\n            if (!isRestSliceType) {\n              _context.next = 18;\n              break;\n            }\n            return _context.abrupt(\"return\", _objectSpread({\n              __mapped: true,\n              id: slice.id,\n              slice_type: sliceType\n            }, result));\n          case 18:\n            return _context.abrupt(\"return\", _objectSpread({\n              __mapped: true,\n              type: sliceType\n            }, result));\n          case 19:\n          case \"end\":\n            return _context.stop();\n        }\n      }, _callee);\n    }));\n    return function (_x, _x2, _x3) {\n      return _ref.apply(this, arguments);\n    };\n  }()));\n}\nexport { unstable_mapSliceZone };","map":{"version":3,"names":["unstable_mapSliceZone","sliceZone","mappers","context","Promise","all","map","_ref","_asyncToGenerator","_regeneratorRuntime","mark","_callee","slice","index","slices","isRestSliceType","sliceType","mapper","mapperArgs","result","wrap","_callee$","_context","prev","next","slice_type","type","abrupt","sent","length","default","_objectSpread","__mapped","id","stop","_x","_x2","_x3","apply","arguments"],"sources":["E:\\Aarhat Iserv - E-commerce\\new\\ariz\\Frontend\\node_modules\\@prismicio\\src\\helpers\\unstable_mapSliceZone.ts"],"sourcesContent":["import { Slice } from \"../types/value/slice\";\n\n/**\n * Convert a value to a lazyily loaded module. This is useful when using\n * functions like `() => import(\"...\")`.\n */\ntype LazyModule<T> = () => Promise<T | { default: T }>;\n\n/**\n * Mark a type as potentially lazy-loaded via a module.\n */\ntype MaybeLazyModule<T> = T | LazyModule<T>;\n\n/**\n * Returns the type of a `SliceLike` type.\n *\n * @typeParam Slice - The Slice from which the type will be extracted.\n */\ntype ExtractSliceType<TSlice extends SliceLike> = TSlice extends Slice\n\t? TSlice[\"slice_type\"]\n\t: TSlice extends SliceGraphQLLike\n\t? TSlice[\"type\"]\n\t: never;\n\n/**\n * The minimum required properties to represent a Prismic Slice from the Prismic\n * GraphQL API for the `unstable_mapSliceZone()` helper.\n *\n * @typeParam SliceType - Type name of the Slice.\n */\ntype SliceGraphQLLike<TSliceType extends string = string> = {\n\ttype: Slice<TSliceType>[\"slice_type\"];\n};\n\n/**\n * The minimum required properties to represent a Prismic Slice for the\n * `unstable_mapSliceZone()` helper.\n *\n * If using Prismic's Rest API V2, use the `Slice` export from\n * `@prismicio/client` for a full interface.\n *\n * @typeParam SliceType - Type name of the Slice.\n */\ntype SliceLike<TSliceType extends string = string> =\n\t| Slice<TSliceType>\n\t| SliceGraphQLLike<TSliceType>;\n\n/**\n * A looser version of the `SliceZone` type from `@prismicio/client` using\n * `SliceLike`.\n *\n * If using Prismic's Rest API V2, use the `SliceZone` export from\n * `@prismicio/client` for the full type.\n *\n * @typeParam TSlice - The type(s) of a Slice in the Slice Zone.\n */\ntype SliceZoneLike<TSlice extends SliceLike = SliceLike> = readonly TSlice[];\n\n/**\n * A set of properties that identify a Slice as having been mapped. Consumers of\n * the mapped Slice Zone can use these properties to detect and specially handle\n * mapped Slices.\n */\ntype MappedSliceLike = {\n\t/**\n\t * If `true`, this Slice has been modified from its original value using a\n\t * mapper.\n\t *\n\t * @internal\n\t */\n\t__mapped: true;\n};\n\n/**\n * Arguments for a function mapping content from a Prismic Slice using the\n * `unstable_mapSliceZone()` helper.\n *\n * @typeParam TSlice - The Slice passed as a prop.\n * @typeParam TContext - Arbitrary data passed to `unstable_mapSliceZone()` and\n *   made available to all Slice mappers.\n */\ntype SliceMapperArgs<\n\tTSlice extends SliceLike = SliceLike,\n\tTContext = unknown,\n> = {\n\t/**\n\t * Slice data.\n\t */\n\tslice: TSlice;\n\n\t/**\n\t * The index of the Slice in the Slice Zone.\n\t */\n\tindex: number;\n\n\t/**\n\t * All Slices from the Slice Zone to which the Slice belongs.\n\t */\n\t// TODO: We have to keep this list of Slices general due to circular\n\t// reference limtiations. If we had another generic to determine the full\n\t// union of Slice types, it would include TSlice. This causes TypeScript to\n\t// throw a compilation error.\n\tslices: SliceZoneLike<\n\t\tTSlice extends SliceGraphQLLike ? SliceGraphQLLike : Slice\n\t>;\n\n\t/**\n\t * Arbitrary data passed to `unstable_mapSliceZone()` and made available to\n\t * all Slice mappers.\n\t */\n\tcontext: TContext;\n};\n\n/**\n * A record of mappers.\n */\nexport type Mappers<\n\tTSlice extends SliceLike = SliceLike,\n\tTContext = unknown,\n> = {\n\t[P in ExtractSliceType<TSlice>]: MaybeLazyModule<\n\t\tMapper<\n\t\t\tExtract<TSlice, SliceLike<P>>,\n\t\t\t// eslint-disable-next-line @typescript-eslint/no-explicit-any\n\t\t\tany,\n\t\t\tTContext\n\t\t>\n\t>;\n};\n\n/**\n * A function that maps a Slice and its metadata to a modified version. The\n * return value will replace the Slice in the Slice Zone.\n */\nexport type Mapper<\n\tTSlice extends SliceLike = SliceLike,\n\tTMappedSlice extends Record<string, unknown> | undefined | void =\n\t\t| Record<string, unknown>\n\t\t| undefined\n\t\t| void,\n\tTContext = unknown,\n> = (\n\targs: MapperArgs<TSlice, TContext>,\n) => TMappedSlice | Promise<TMappedSlice>;\n\n/**\n * Arguments provided to a mapper function.\n */\nexport type MapperArgs<\n\tTSlice extends SliceLike = SliceLike,\n\tTContext = unknown,\n> = SliceMapperArgs<TSlice, TContext>;\n\n/**\n * Unwraps a lazily loaded mapper module.\n */\ntype ResolveLazyMapperModule<TMapper extends Mapper | LazyModule<Mapper>> =\n\tTMapper extends LazyModule<Mapper>\n\t\t? Awaited<ReturnType<TMapper>> extends {\n\t\t\t\tdefault: unknown;\n\t\t  }\n\t\t\t? Awaited<ReturnType<TMapper>>[\"default\"]\n\t\t\t: Awaited<ReturnType<TMapper>>\n\t\t: TMapper;\n\n/**\n * Transforms a Slice into its mapped version.\n */\ntype MapSliceLike<\n\tTSliceLike extends SliceLike,\n\tTMappers extends Mappers,\n> = TSliceLike extends Slice\n\t? TSliceLike[\"slice_type\"] extends keyof TMappers\n\t\t? Slice<TSliceLike[\"slice_type\"]> &\n\t\t\t\tMappedSliceLike &\n\t\t\t\tAwaited<\n\t\t\t\t\tReturnType<\n\t\t\t\t\t\tResolveLazyMapperModule<TMappers[TSliceLike[\"slice_type\"]]>\n\t\t\t\t\t>\n\t\t\t\t>\n\t\t: TSliceLike\n\t: TSliceLike extends SliceGraphQLLike\n\t? TSliceLike[\"type\"] extends keyof TMappers\n\t\t? SliceGraphQLLike<TSliceLike[\"type\"]> &\n\t\t\t\tMappedSliceLike &\n\t\t\t\tAwaited<\n\t\t\t\t\tReturnType<ResolveLazyMapperModule<TMappers[TSliceLike[\"type\"]]>>\n\t\t\t\t>\n\t\t: TSliceLike\n\t: never;\n\n/**\n * Transforms a Slice Zone using a set of mapping functions, one for each type\n * of Slice. Mapping functions can be async.\n *\n * Whenever possible, use this function on the server to minimize client-side\n * processing.\n *\n * @example\n *\n * ```typescript\n * const mappedSliceZone = await unstable_mapSliceZone(page.data.slices, {\n * \tcode_block: ({ slice }) => ({\n * \t\tcodeHTML: await highlight(slice.primary.code),\n * \t}),\n * });\n * ```\n *\n * @experimental Names and implementations may change in the future.\n * `unstable_mapSliceZone()` does not follow SemVer.\n */\nexport function unstable_mapSliceZone<\n\tTSliceLike extends SliceLike,\n\tTMappers extends Mappers,\n\tTContext = unknown,\n>(\n\tsliceZone: SliceZoneLike<TSliceLike>,\n\tmappers: TMappers,\n\tcontext?: TContext,\n): Promise<MapSliceLike<TSliceLike, TMappers>[]> {\n\treturn Promise.all(\n\t\tsliceZone.map(async (slice, index, slices) => {\n\t\t\tconst isRestSliceType = \"slice_type\" in slice;\n\t\t\tconst sliceType = isRestSliceType ? slice.slice_type : slice.type;\n\n\t\t\tconst mapper = mappers[sliceType];\n\n\t\t\tif (!mapper) {\n\t\t\t\treturn slice;\n\t\t\t}\n\n\t\t\tconst mapperArgs = { slice, slices, index, context };\n\n\t\t\t// `result` may be a mapper function OR a module\n\t\t\t// containing a mapper function.\n\t\t\tlet result = await mapper(mapperArgs);\n\n\t\t\t// `result` is a module containing a mapper function,\n\t\t\t// we need to dig out the mapper function. `result`\n\t\t\t// will be reassigned with the mapper function's value.\n\t\t\tif (\n\t\t\t\t// `mapper.length < 1` ensures the given\n\t\t\t\t// function is something of the form:\n\t\t\t\t// `() => import(...)`\n\t\t\t\tmapper.length < 1 &&\n\t\t\t\t(typeof result === \"function\" ||\n\t\t\t\t\t(typeof result === \"object\" && \"default\" in result))\n\t\t\t) {\n\t\t\t\tresult = \"default\" in result ? result.default : result;\n\t\t\t\tresult = await result(mapperArgs);\n\t\t\t}\n\n\t\t\tif (isRestSliceType) {\n\t\t\t\treturn {\n\t\t\t\t\t__mapped: true,\n\t\t\t\t\tid: slice.id,\n\t\t\t\t\tslice_type: sliceType,\n\t\t\t\t\t...result,\n\t\t\t\t};\n\t\t\t} else {\n\t\t\t\treturn {\n\t\t\t\t\t__mapped: true,\n\t\t\t\t\ttype: sliceType,\n\t\t\t\t\t...result,\n\t\t\t\t};\n\t\t\t}\n\t\t}),\n\t);\n}\n"],"mappings":";;;AAmNgB,SAAAA,sBAKfC,SAAA,EACAC,OAAA,EACAC,OAAA,EAAkB;EAElB,OAAOC,OAAA,CAAQC,GAAA,CACdJ,SAAA,CAAUK,GAAA;IAAA,IAAAC,IAAA,GAAAC,iBAAA,eAAAC,mBAAA,GAAAC,IAAA,CAAI,SAAAC,QAAOC,KAAA,EAAOC,KAAA,EAAOC,MAAA;MAAA,IAAAC,eAAA,EAAAC,SAAA,EAAAC,MAAA,EAAAC,UAAA,EAAAC,MAAA;MAAA,OAAAV,mBAAA,GAAAW,IAAA,UAAAC,SAAAC,QAAA;QAAA,kBAAAA,QAAA,CAAAC,IAAA,GAAAD,QAAA,CAAAE,IAAA;UAAA;YAC5BT,eAAA,GAAkB,gBAAgBH,KAAA;YAClCI,SAAA,GAAYD,eAAA,GAAkBH,KAAA,CAAMa,UAAA,GAAab,KAAA,CAAMc,IAAA;YAEvDT,MAAA,GAASf,OAAA,CAAQc,SAAS;YAAA,IAE3BC,MAAA;cAAAK,QAAA,CAAAE,IAAA;cAAA;YAAA;YAAA,OAAAF,QAAA,CAAAK,MAAA,WACGf,KAAA;UAAA;YAGFM,UAAA,GAAa;cAAEN,KAAA,EAAAA,KAAA;cAAOE,MAAA,EAAAA,MAAA;cAAQD,KAAA,EAAAA,KAAA;cAAOV,OAAA,EAAAA;YAAO;YAAAmB,QAAA,CAAAE,IAAA;YAAA,OAI/BP,MAAA,CAAOC,UAAU;UAAA;YAAhCC,MAAA,GAAAG,QAAA,CAAAM,IAAA;YAAA;YAKJ;YAAA;YAAA;YAICX,MAAA,CAAOY,MAAA,GAAS,MACf,OAAOV,MAAA,KAAW,cACjB,OAAOA,MAAA,KAAW,YAAY,aAAaA,MAAA;cAAAG,QAAA,CAAAE,IAAA;cAAA;YAAA;YAEpCL,MAAA,gBAAaA,MAAA,GAASA,MAAA,CAAOW,OAAA,GAAUX,MAAA;YAAAG,QAAA,CAAAE,IAAA;YAAA,OACjCL,MAAA,CAAOD,UAAU;UAAA;YAAvBC,MAAA,GAAAG,QAAA,CAAAM,IAAA;UAAA;YAAA,KAGNb,eAAA;cAAAO,QAAA,CAAAE,IAAA;cAAA;YAAA;YAAA,OAAAF,QAAA,CAAAK,MAAA,WAAAI,aAAA;cAEFC,QAAA,EAAU;cACVC,EAAA,EAAIrB,KAAA,CAAMqB,EAAA;cACVR,UAAA,EAAYT;YAAA,GACTG,MAAA;UAAA;YAAA,OAAAG,QAAA,CAAAK,MAAA,WAAAI,aAAA;cAIHC,QAAA,EAAU;cACVN,IAAA,EAAMV;YAAA,GACHG,MAAA;UAAA;UAAA;YAAA,OAAAG,QAAA,CAAAY,IAAA;QAAA;MAAA,GAAAvB,OAAA;IAAA,CAGL;IAAA,iBAAAwB,EAAA,EAAAC,GAAA,EAAAC,GAAA;MAAA,OAAA9B,IAAA,CAAA+B,KAAA,OAAAC,SAAA;IAAA;EAAA,IAAC;AAEJ"},"metadata":{},"sourceType":"module","externalDependencies":[]}