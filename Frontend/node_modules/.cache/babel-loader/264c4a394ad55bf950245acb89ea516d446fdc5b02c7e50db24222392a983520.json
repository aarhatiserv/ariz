{"ast":null,"code":"import * as React from \"react\";\nimport { usePrismicClient } from \"./usePrismicClient.js\";\nconst reducer = (state, action) => {\n  switch (action[0]) {\n    case \"start\":\n      {\n        return {\n          state: \"loading\"\n        };\n      }\n    case \"succeed\":\n      {\n        return {\n          state: \"loaded\",\n          data: action[1]\n        };\n      }\n    case \"fail\":\n      {\n        return {\n          ...state,\n          state: \"failed\",\n          error: action[1]\n        };\n      }\n  }\n};\nconst initialState = {\n  state: \"idle\"\n};\nconst isParams = value => {\n  return typeof value === \"object\" && value !== null && !Array.isArray(value);\n};\nconst useStatefulPrismicClientMethod = (methodName, args, explicitClient) => {\n  const lastArg = args[args.length - 1];\n  const {\n    client: lastArgExplicitClient,\n    skip,\n    ...params\n  } = isParams(lastArg) ? lastArg : {};\n  const argsWithoutParams = isParams(lastArg) ? args.slice(0, -1) : args;\n  const client = usePrismicClient(explicitClient || lastArgExplicitClient);\n  const [state, dispatch] = React.useReducer(reducer, initialState);\n  React.useEffect(() => {\n    if (!skip) {\n      {\n        dispatch([\"start\"]);\n      }\n      client[methodName].call(client, ...argsWithoutParams, params).then(result => {\n        {\n          dispatch([\"succeed\", result]);\n        }\n      }).catch(error => {\n        {\n          dispatch([\"fail\", error]);\n        }\n      });\n    }\n  },\n  // We must disable exhaustive-deps since we are using\n  // JSON.stringify on params (effectively a deep equality check).\n  // We want this effect to run again anytime params change.\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  [client, methodName, skip,\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  JSON.stringify(argsWithoutParams),\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  JSON.stringify(params)]);\n  return React.useMemo(() => [state.data, {\n    state: state.state,\n    error: state.error\n  }], [state]);\n};\nexport { useStatefulPrismicClientMethod };","map":{"version":3,"names":["reducer","state","action","data","error","initialState","isParams","value","Array","isArray","useStatefulPrismicClientMethod","methodName","args","explicitClient","lastArg","length","client","lastArgExplicitClient","skip","params","argsWithoutParams","slice","usePrismicClient","dispatch","React","useReducer","useEffect","call","then","result","catch","JSON","stringify","useMemo"],"sources":["E:\\Aarhat Iserv - E-commerce\\new\\ariz\\Frontend\\node_modules\\@prismicio\\src\\useStatefulPrismicClientMethod.ts"],"sourcesContent":["import type * as prismic from \"@prismicio/client\";\n\nimport * as React from \"react\";\n\nimport { PrismicClientHookState } from \"./types\";\nimport { usePrismicClient } from \"./usePrismicClient\";\n\ntype StateMachineState<TData> = {\n\tstate: PrismicClientHookState;\n\tdata?: TData;\n\terror?: Error;\n};\n\ntype StateMachineAction<TData> =\n\t| [type: \"start\"]\n\t| [type: \"succeed\", payload: TData]\n\t| [type: \"fail\", payload: Error];\n\nconst reducer = <TData>(\n\tstate: StateMachineState<TData>,\n\taction: StateMachineAction<TData>,\n): StateMachineState<TData> => {\n\tswitch (action[0]) {\n\t\tcase \"start\": {\n\t\t\treturn { state: \"loading\" };\n\t\t}\n\n\t\tcase \"succeed\": {\n\t\t\treturn { state: \"loaded\", data: action[1] };\n\t\t}\n\n\t\tcase \"fail\": {\n\t\t\treturn {\n\t\t\t\t...state,\n\t\t\t\tstate: \"failed\",\n\t\t\t\terror: action[1],\n\t\t\t};\n\t\t}\n\t}\n};\n\nconst initialState: StateMachineState<never> = {\n\tstate: \"idle\",\n};\n\ntype UnwrapPromise<T> = T extends Promise<infer U> ? U : T;\n\ntype ClientPrototype = typeof prismic.Client.prototype;\n\ntype ClientMethod<MethodName extends keyof ClientPrototype> =\n\t// eslint-disable-next-line @typescript-eslint/no-explicit-any\n\tClientPrototype[MethodName] extends (...args: any[]) => any\n\t\t? ClientPrototype[MethodName]\n\t\t: never;\n\ntype ClientMethodName = keyof {\n\t[P in keyof prismic.Client as prismic.Client[P] extends (\n\t\t// eslint-disable-next-line @typescript-eslint/no-explicit-any\n\t\t...args: any[]\n\t) => // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\tPromise<any>\n\t\t? P\n\t\t: never]: unknown;\n};\n\nexport type ClientMethodParameters<MethodName extends keyof ClientPrototype> =\n\tParameters<ClientMethod<MethodName>>;\n\nexport type HookOnlyParameters = {\n\tclient?: prismic.Client;\n\tskip?: boolean;\n};\n\n/**\n * Determines if a value is a `@prismicio/client` params object.\n *\n * @param value - The value to check.\n *\n * @returns `true` if `value` is a `@prismicio/client` params object, `false`\n *   otherwise.\n */\nconst isParams = (\n\tvalue: unknown,\n): value is ClientMethodParameters<\"get\">[0] & HookOnlyParameters => {\n\t// This is a *very* naive check.\n\treturn typeof value === \"object\" && value !== null && !Array.isArray(value);\n};\n\n/**\n * The return value of a `@prismicio/client` React hook.\n *\n * @typeParam TData - Data returned by the client.\n */\nexport type ClientHookReturnType<TData = unknown> = [\n\t/**\n\t * Data returned by the client.\n\t */\n\tdata: TData | undefined,\n\n\t/**\n\t * The current state of the hook's client method call.\n\t */\n\tstate: Pick<StateMachineState<TData>, \"state\" | \"error\">,\n];\n\n/**\n * Creates a React hook that forwards arguments to a specific method of a\n * `@prismicio/client` instance. The created hook has its own internal state\n * manager to report async status, such as pending or error statuses.\n *\n * @param methodName - The `@prismicio/client` method to which hook arguments\n *   will be forwarded.\n *\n * @returns A new React hook configured for the provided method.\n *\n * @internal\n */\nexport const useStatefulPrismicClientMethod = <\n\tTMethodName extends ClientMethodName,\n\tTArgs extends Parameters<ClientMethod<TMethodName>>,\n\tTData extends UnwrapPromise<ReturnType<ClientMethod<TMethodName>>>,\n>(\n\tmethodName: TMethodName,\n\targs: TArgs,\n\texplicitClient?: prismic.Client,\n): ClientHookReturnType<TData> => {\n\tconst lastArg = args[args.length - 1];\n\tconst {\n\t\tclient: lastArgExplicitClient,\n\t\tskip,\n\t\t...params\n\t} = isParams(lastArg) ? lastArg : ({} as HookOnlyParameters);\n\tconst argsWithoutParams = isParams(lastArg) ? args.slice(0, -1) : args;\n\n\tconst client = usePrismicClient(explicitClient || lastArgExplicitClient);\n\n\tconst [state, dispatch] = React.useReducer<\n\t\tReact.Reducer<StateMachineState<TData>, StateMachineAction<TData>>\n\t>(reducer, initialState);\n\n\tReact.useEffect(\n\t\t() => {\n\t\t\t// Used to prevent dispatching an action if the hook was cleaned up.\n\t\t\tlet didCancel = false;\n\n\t\t\tif (!skip) {\n\t\t\t\tif (!didCancel) {\n\t\t\t\t\tdispatch([\"start\"]);\n\t\t\t\t}\n\n\t\t\t\tclient[methodName]\n\t\t\t\t\t.call(\n\t\t\t\t\t\tclient,\n\t\t\t\t\t\t// @ts-expect-error - Merging method arg types is too complex\n\t\t\t\t\t\t...argsWithoutParams,\n\t\t\t\t\t\tparams,\n\t\t\t\t\t)\n\t\t\t\t\t.then((result) => {\n\t\t\t\t\t\tif (!didCancel) {\n\t\t\t\t\t\t\tdispatch([\"succeed\", result as TData]);\n\t\t\t\t\t\t}\n\t\t\t\t\t})\n\t\t\t\t\t.catch((error) => {\n\t\t\t\t\t\tif (!didCancel) {\n\t\t\t\t\t\t\tdispatch([\"fail\", error]);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t}\n\n\t\t\t// Ensure we don't dispatch an action if the hook is cleaned up.\n\t\t\t() => {\n\t\t\t\tdidCancel = true;\n\t\t\t};\n\t\t},\n\t\t// We must disable exhaustive-deps since we are using\n\t\t// JSON.stringify on params (effectively a deep equality check).\n\t\t// We want this effect to run again anytime params change.\n\t\t// eslint-disable-next-line react-hooks/exhaustive-deps\n\t\t[\n\t\t\tclient,\n\t\t\tmethodName,\n\t\t\tskip,\n\t\t\t// eslint-disable-next-line react-hooks/exhaustive-deps\n\t\t\tJSON.stringify(argsWithoutParams),\n\t\t\t// eslint-disable-next-line react-hooks/exhaustive-deps\n\t\t\tJSON.stringify(params),\n\t\t],\n\t);\n\n\treturn React.useMemo(\n\t\t() => [\n\t\t\tstate.data,\n\t\t\t{\n\t\t\t\tstate: state.state,\n\t\t\t\terror: state.error,\n\t\t\t},\n\t\t],\n\t\t[state],\n\t);\n};\n"],"mappings":";;AAkBA,MAAMA,OAAA,GAAUA,CACfC,KAAA,EACAC,MAAA,KAC6B;EACrB,QAAAA,MAAA,CAAO,CAAC;IACf,KAAK;MAAS;QACN;UAAED,KAAA,EAAO;QAAA;MAChB;IAED,KAAK;MAAW;QACf,OAAO;UAAEA,KAAA,EAAO;UAAUE,IAAA,EAAMD,MAAA,CAAO,CAAC;QAAA;MACxC;IAED,KAAK;MAAQ;QACL;UACN,GAAGD,KAAA;UACHA,KAAA,EAAO;UACPG,KAAA,EAAOF,MAAA,CAAO,CAAC;QAAA;MAEhB;EACD;AACF;AAEA,MAAMG,YAAA,GAAyC;EAC9CJ,KAAA,EAAO;;AAuCR,MAAMK,QAAA,GACLC,KAAA,IACmE;EAE5D,cAAOA,KAAA,KAAU,YAAYA,KAAA,KAAU,QAAQ,CAACC,KAAA,CAAMC,OAAA,CAAQF,KAAK;AAC3E;AA+BO,MAAMG,8BAAA,GAAiCA,CAK7CC,UAAA,EACAC,IAAA,EACAC,cAAA,KACgC;EAChC,MAAMC,OAAA,GAAUF,IAAA,CAAKA,IAAA,CAAKG,MAAA,GAAS,CAAC;EAC9B;IACLC,MAAA,EAAQC,qBAAA;IACRC,IAAA;IACA,GAAGC;EAAA,IACAb,QAAA,CAASQ,OAAO,IAAIA,OAAA,GAAW;EAC7B,MAAAM,iBAAA,GAAoBd,QAAA,CAASQ,OAAO,IAAIF,IAAA,CAAKS,KAAA,CAAM,GAAG,EAAE,IAAIT,IAAA;EAE5D,MAAAI,MAAA,GAASM,gBAAA,CAAiBT,cAAA,IAAkBI,qBAAqB;EAEvE,MAAM,CAAChB,KAAA,EAAOsB,QAAQ,IAAIC,KAAA,CAAMC,UAAA,CAE9BzB,OAAA,EAASK,YAAY;EAEjBmB,KAAA,CAAAE,SAAA,CACL,MAAK;IAIJ,IAAI,CAACR,IAAA,EAAM;MACM;QACNK,QAAA,EAAC,OAAO,CAAC;MAClB;MAEDP,MAAA,CAAOL,UAAU,EACfgB,IAAA,CACAX,MAAA,EAEA,GAAGI,iBAAA,EACHD,MAAA,EAEAS,IAAA,CAAMC,MAAA,IAAU;QACA;UACNN,QAAA,EAAC,WAAWM,MAAe,CAAC;QACrC;MAAA,CACD,EACAC,KAAA,CAAO1B,KAAA,IAAS;QACA;UACNmB,QAAA,EAAC,QAAQnB,KAAK,CAAC;QACxB;MAAA,CACD;IACF;EAMF;EAAA;EAAA;EAAA;EAAA;EAKA,CACCY,MAAA,EACAL,UAAA,EACAO,IAAA;EAAA;EAEAa,IAAA,CAAKC,SAAA,CAAUZ,iBAAiB;EAAA;EAEhCW,IAAA,CAAKC,SAAA,CAAUb,MAAM,EACrB;EAGK,OAAAK,KAAA,CAAMS,OAAA,CACZ,MAAM,CACLhC,KAAA,CAAME,IAAA,EACN;IACCF,KAAA,EAAOA,KAAA,CAAMA,KAAA;IACbG,KAAA,EAAOH,KAAA,CAAMG;EACb,IAEF,CAACH,KAAK,CAAC;AAET"},"metadata":{},"sourceType":"module","externalDependencies":[]}