{"ast":null,"code":"import _toConsumableArray from \"E:/Aarhat Iserv - E-commerce/new/ariz/Frontend/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport _slicedToArray from \"E:/Aarhat Iserv - E-commerce/new/ariz/Frontend/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _objectWithoutProperties from \"E:/Aarhat Iserv - E-commerce/new/ariz/Frontend/node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js\";\nimport _objectSpread from \"E:/Aarhat Iserv - E-commerce/new/ariz/Frontend/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nvar _excluded = [\"client\", \"skip\"];\nimport * as React from \"react\";\nimport { usePrismicClient } from \"./usePrismicClient.js\";\nvar reducer = function reducer(state, action) {\n  switch (action[0]) {\n    case \"start\":\n      {\n        return {\n          state: \"loading\"\n        };\n      }\n    case \"succeed\":\n      {\n        return {\n          state: \"loaded\",\n          data: action[1]\n        };\n      }\n    case \"fail\":\n      {\n        return _objectSpread(_objectSpread({}, state), {}, {\n          state: \"failed\",\n          error: action[1]\n        });\n      }\n  }\n};\nvar initialState = {\n  state: \"idle\"\n};\nvar isParams = function isParams(value) {\n  return typeof value === \"object\" && value !== null && !Array.isArray(value);\n};\nvar useStatefulPrismicClientMethod = function useStatefulPrismicClientMethod(methodName, args, explicitClient) {\n  var lastArg = args[args.length - 1];\n  var _ref = isParams(lastArg) ? lastArg : {},\n    lastArgExplicitClient = _ref.client,\n    skip = _ref.skip,\n    params = _objectWithoutProperties(_ref, _excluded);\n  var argsWithoutParams = isParams(lastArg) ? args.slice(0, -1) : args;\n  var client = usePrismicClient(explicitClient || lastArgExplicitClient);\n  var _React$useReducer = React.useReducer(reducer, initialState),\n    _React$useReducer2 = _slicedToArray(_React$useReducer, 2),\n    state = _React$useReducer2[0],\n    dispatch = _React$useReducer2[1];\n  React.useEffect(function () {\n    if (!skip) {\n      var _client$methodName;\n      {\n        dispatch([\"start\"]);\n      }\n      (_client$methodName = client[methodName]).call.apply(_client$methodName, [client].concat(_toConsumableArray(argsWithoutParams), [params])).then(function (result) {\n        {\n          dispatch([\"succeed\", result]);\n        }\n      }).catch(function (error) {\n        {\n          dispatch([\"fail\", error]);\n        }\n      });\n    }\n  },\n  // We must disable exhaustive-deps since we are using\n  // JSON.stringify on params (effectively a deep equality check).\n  // We want this effect to run again anytime params change.\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  [client, methodName, skip,\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  JSON.stringify(argsWithoutParams),\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  JSON.stringify(params)]);\n  return React.useMemo(function () {\n    return [state.data, {\n      state: state.state,\n      error: state.error\n    }];\n  }, [state]);\n};\nexport { useStatefulPrismicClientMethod };","map":{"version":3,"names":["reducer","state","action","data","_objectSpread","error","initialState","isParams","value","Array","isArray","useStatefulPrismicClientMethod","methodName","args","explicitClient","lastArg","length","_ref","lastArgExplicitClient","client","skip","params","_objectWithoutProperties","_excluded","argsWithoutParams","slice","usePrismicClient","_React$useReducer","React","useReducer","_React$useReducer2","_slicedToArray","dispatch","useEffect","_client$methodName","call","apply","concat","_toConsumableArray","then","result","catch","JSON","stringify","useMemo"],"sources":["E:\\Aarhat Iserv - E-commerce\\new\\ariz\\Frontend\\node_modules\\@prismicio\\src\\useStatefulPrismicClientMethod.ts"],"sourcesContent":["import type * as prismic from \"@prismicio/client\";\n\nimport * as React from \"react\";\n\nimport { PrismicClientHookState } from \"./types\";\nimport { usePrismicClient } from \"./usePrismicClient\";\n\ntype StateMachineState<TData> = {\n\tstate: PrismicClientHookState;\n\tdata?: TData;\n\terror?: Error;\n};\n\ntype StateMachineAction<TData> =\n\t| [type: \"start\"]\n\t| [type: \"succeed\", payload: TData]\n\t| [type: \"fail\", payload: Error];\n\nconst reducer = <TData>(\n\tstate: StateMachineState<TData>,\n\taction: StateMachineAction<TData>,\n): StateMachineState<TData> => {\n\tswitch (action[0]) {\n\t\tcase \"start\": {\n\t\t\treturn { state: \"loading\" };\n\t\t}\n\n\t\tcase \"succeed\": {\n\t\t\treturn { state: \"loaded\", data: action[1] };\n\t\t}\n\n\t\tcase \"fail\": {\n\t\t\treturn {\n\t\t\t\t...state,\n\t\t\t\tstate: \"failed\",\n\t\t\t\terror: action[1],\n\t\t\t};\n\t\t}\n\t}\n};\n\nconst initialState: StateMachineState<never> = {\n\tstate: \"idle\",\n};\n\ntype UnwrapPromise<T> = T extends Promise<infer U> ? U : T;\n\ntype ClientPrototype = typeof prismic.Client.prototype;\n\ntype ClientMethod<MethodName extends keyof ClientPrototype> =\n\t// eslint-disable-next-line @typescript-eslint/no-explicit-any\n\tClientPrototype[MethodName] extends (...args: any[]) => any\n\t\t? ClientPrototype[MethodName]\n\t\t: never;\n\ntype ClientMethodName = keyof {\n\t[P in keyof prismic.Client as prismic.Client[P] extends (\n\t\t// eslint-disable-next-line @typescript-eslint/no-explicit-any\n\t\t...args: any[]\n\t) => // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\tPromise<any>\n\t\t? P\n\t\t: never]: unknown;\n};\n\nexport type ClientMethodParameters<MethodName extends keyof ClientPrototype> =\n\tParameters<ClientMethod<MethodName>>;\n\nexport type HookOnlyParameters = {\n\tclient?: prismic.Client;\n\tskip?: boolean;\n};\n\n/**\n * Determines if a value is a `@prismicio/client` params object.\n *\n * @param value - The value to check.\n *\n * @returns `true` if `value` is a `@prismicio/client` params object, `false`\n *   otherwise.\n */\nconst isParams = (\n\tvalue: unknown,\n): value is ClientMethodParameters<\"get\">[0] & HookOnlyParameters => {\n\t// This is a *very* naive check.\n\treturn typeof value === \"object\" && value !== null && !Array.isArray(value);\n};\n\n/**\n * The return value of a `@prismicio/client` React hook.\n *\n * @typeParam TData - Data returned by the client.\n */\nexport type ClientHookReturnType<TData = unknown> = [\n\t/**\n\t * Data returned by the client.\n\t */\n\tdata: TData | undefined,\n\n\t/**\n\t * The current state of the hook's client method call.\n\t */\n\tstate: Pick<StateMachineState<TData>, \"state\" | \"error\">,\n];\n\n/**\n * Creates a React hook that forwards arguments to a specific method of a\n * `@prismicio/client` instance. The created hook has its own internal state\n * manager to report async status, such as pending or error statuses.\n *\n * @param methodName - The `@prismicio/client` method to which hook arguments\n *   will be forwarded.\n *\n * @returns A new React hook configured for the provided method.\n *\n * @internal\n */\nexport const useStatefulPrismicClientMethod = <\n\tTMethodName extends ClientMethodName,\n\tTArgs extends Parameters<ClientMethod<TMethodName>>,\n\tTData extends UnwrapPromise<ReturnType<ClientMethod<TMethodName>>>,\n>(\n\tmethodName: TMethodName,\n\targs: TArgs,\n\texplicitClient?: prismic.Client,\n): ClientHookReturnType<TData> => {\n\tconst lastArg = args[args.length - 1];\n\tconst {\n\t\tclient: lastArgExplicitClient,\n\t\tskip,\n\t\t...params\n\t} = isParams(lastArg) ? lastArg : ({} as HookOnlyParameters);\n\tconst argsWithoutParams = isParams(lastArg) ? args.slice(0, -1) : args;\n\n\tconst client = usePrismicClient(explicitClient || lastArgExplicitClient);\n\n\tconst [state, dispatch] = React.useReducer<\n\t\tReact.Reducer<StateMachineState<TData>, StateMachineAction<TData>>\n\t>(reducer, initialState);\n\n\tReact.useEffect(\n\t\t() => {\n\t\t\t// Used to prevent dispatching an action if the hook was cleaned up.\n\t\t\tlet didCancel = false;\n\n\t\t\tif (!skip) {\n\t\t\t\tif (!didCancel) {\n\t\t\t\t\tdispatch([\"start\"]);\n\t\t\t\t}\n\n\t\t\t\tclient[methodName]\n\t\t\t\t\t.call(\n\t\t\t\t\t\tclient,\n\t\t\t\t\t\t// @ts-expect-error - Merging method arg types is too complex\n\t\t\t\t\t\t...argsWithoutParams,\n\t\t\t\t\t\tparams,\n\t\t\t\t\t)\n\t\t\t\t\t.then((result) => {\n\t\t\t\t\t\tif (!didCancel) {\n\t\t\t\t\t\t\tdispatch([\"succeed\", result as TData]);\n\t\t\t\t\t\t}\n\t\t\t\t\t})\n\t\t\t\t\t.catch((error) => {\n\t\t\t\t\t\tif (!didCancel) {\n\t\t\t\t\t\t\tdispatch([\"fail\", error]);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t}\n\n\t\t\t// Ensure we don't dispatch an action if the hook is cleaned up.\n\t\t\t() => {\n\t\t\t\tdidCancel = true;\n\t\t\t};\n\t\t},\n\t\t// We must disable exhaustive-deps since we are using\n\t\t// JSON.stringify on params (effectively a deep equality check).\n\t\t// We want this effect to run again anytime params change.\n\t\t// eslint-disable-next-line react-hooks/exhaustive-deps\n\t\t[\n\t\t\tclient,\n\t\t\tmethodName,\n\t\t\tskip,\n\t\t\t// eslint-disable-next-line react-hooks/exhaustive-deps\n\t\t\tJSON.stringify(argsWithoutParams),\n\t\t\t// eslint-disable-next-line react-hooks/exhaustive-deps\n\t\t\tJSON.stringify(params),\n\t\t],\n\t);\n\n\treturn React.useMemo(\n\t\t() => [\n\t\t\tstate.data,\n\t\t\t{\n\t\t\t\tstate: state.state,\n\t\t\t\terror: state.error,\n\t\t\t},\n\t\t],\n\t\t[state],\n\t);\n};\n"],"mappings":";;;;;;;AAkBA,IAAMA,OAAA,GAAU,SAAVA,QACLC,KAAA,EACAC,MAAA,EAC6B;EACrB,QAAAA,MAAA,CAAO,CAAC;IACf,KAAK;MAAS;QACN;UAAED,KAAA,EAAO;QAAA;MAChB;IAED,KAAK;MAAW;QACf,OAAO;UAAEA,KAAA,EAAO;UAAUE,IAAA,EAAMD,MAAA,CAAO,CAAC;QAAA;MACxC;IAED,KAAK;MAAQ;QACL,OAAAE,aAAA,CAAAA,aAAA,KACHH,KAAA;UACHA,KAAA,EAAO;UACPI,KAAA,EAAOH,MAAA,CAAO,CAAC;QAAA;MAEhB;EACD;AACF;AAEA,IAAMI,YAAA,GAAyC;EAC9CL,KAAA,EAAO;;AAuCR,IAAMM,QAAA,GAAW,SAAXA,SACLC,KAAA,EACmE;EAE5D,cAAOA,KAAA,KAAU,YAAYA,KAAA,KAAU,QAAQ,CAACC,KAAA,CAAMC,OAAA,CAAQF,KAAK;AAC3E;AA+BO,IAAMG,8BAAA,GAAiC,SAAjCA,+BAKZC,UAAA,EACAC,IAAA,EACAC,cAAA,EACgC;EAChC,IAAMC,OAAA,GAAUF,IAAA,CAAKA,IAAA,CAAKG,MAAA,GAAS,CAAC;EAC9B,IAAAC,IAAA,GAIFV,QAAA,CAASQ,OAAO,IAAIA,OAAA,GAAW;IAH1BG,qBAAA,GAAAD,IAAA,CAARE,MAAA;IACAC,IAAA,GAAAH,IAAA,CAAAG,IAAA;IACGC,MAAA,GAAAC,wBAAA,CAAAL,IAAA,EAAAM,SAAA;EAEE,IAAAC,iBAAA,GAAoBjB,QAAA,CAASQ,OAAO,IAAIF,IAAA,CAAKY,KAAA,CAAM,GAAG,EAAE,IAAIZ,IAAA;EAE5D,IAAAM,MAAA,GAASO,gBAAA,CAAiBZ,cAAA,IAAkBI,qBAAqB;EAEvE,IAAAS,iBAAA,GAA0BC,KAAA,CAAMC,UAAA,CAE9B7B,OAAA,EAASM,YAAY;IAAAwB,kBAAA,GAAAC,cAAA,CAAAJ,iBAAA;IAFhB1B,KAAA,GAAA6B,kBAAA;IAAOE,QAAQ,GAAAF,kBAAA;EAIhBF,KAAA,CAAAK,SAAA,CACL,YAAK;IAIJ,IAAI,CAACb,IAAA,EAAM;MAAA,IAAAc,kBAAA;MACM;QACNF,QAAA,EAAC,OAAO,CAAC;MAClB;MAED,CAAAE,kBAAA,GAAAf,MAAA,CAAOP,UAAU,GACfuB,IAAA,CAAAC,KAAA,CAAAF,kBAAA,GACAf,MAAA,EAAAkB,MAAA,CAAAC,kBAAA,CAEGd,iBAAA,IACHH,MAAA,IAEAkB,IAAA,CAAK,UAACC,MAAA,EAAU;QACA;UACNR,QAAA,EAAC,WAAWQ,MAAe,CAAC;QACrC;MAAA,CACD,EACAC,KAAA,CAAM,UAACpC,KAAA,EAAS;QACA;UACN2B,QAAA,EAAC,QAAQ3B,KAAK,CAAC;QACxB;MAAA,CACD;IACF;EAMF;EAAA;EAAA;EAAA;EAAA;EAKA,CACCc,MAAA,EACAP,UAAA,EACAQ,IAAA;EAAA;EAEAsB,IAAA,CAAKC,SAAA,CAAUnB,iBAAiB;EAAA;EAEhCkB,IAAA,CAAKC,SAAA,CAAUtB,MAAM,EACrB;EAGK,OAAAO,KAAA,CAAMgB,OAAA,CACZ;IAAA,OAAM,CACL3C,KAAA,CAAME,IAAA,EACN;MACCF,KAAA,EAAOA,KAAA,CAAMA,KAAA;MACbI,KAAA,EAAOJ,KAAA,CAAMI;IACb;EAAA,GAEF,CAACJ,KAAK,CAAC;AAET"},"metadata":{},"sourceType":"module","externalDependencies":[]}