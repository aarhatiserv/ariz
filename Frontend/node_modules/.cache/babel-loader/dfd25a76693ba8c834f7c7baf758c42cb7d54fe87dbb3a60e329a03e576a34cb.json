{"ast":null,"code":"import { RichTextNodeType } from \"@prismicio/types\";\nconst uuid = () => {\n  return (++uuid.i).toString();\n};\nuuid.i = 0;\nconst asTree = nodes => {\n  const preparedNodes = prepareNodes(nodes);\n  const children = [];\n  for (let i = 0; i < preparedNodes.length; i++) {\n    children.push(nodeToTreeNode(preparedNodes[i]));\n  }\n  return {\n    key: uuid(),\n    children\n  };\n};\nconst createTreeNode = function (node) {\n  let children = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n  return {\n    key: uuid(),\n    type: node.type,\n    text: \"text\" in node ? node.text : void 0,\n    node,\n    children\n  };\n};\nconst createTextTreeNode = text => {\n  return createTreeNode({\n    type: RichTextNodeType.span,\n    text,\n    spans: []\n  });\n};\nconst prepareNodes = nodes => {\n  const mutNodes = nodes.slice(0);\n  for (let i = 0; i < mutNodes.length; i++) {\n    const node = mutNodes[i];\n    if (node.type === RichTextNodeType.listItem || node.type === RichTextNodeType.oListItem) {\n      const items = [node];\n      while (mutNodes[i + 1] && mutNodes[i + 1].type === node.type) {\n        items.push(mutNodes[i + 1]);\n        mutNodes.splice(i, 1);\n      }\n      if (node.type === RichTextNodeType.listItem) {\n        mutNodes[i] = {\n          type: RichTextNodeType.list,\n          items\n        };\n      } else {\n        mutNodes[i] = {\n          type: RichTextNodeType.oList,\n          items\n        };\n      }\n    }\n  }\n  return mutNodes;\n};\nconst nodeToTreeNode = node => {\n  if (\"text\" in node) {\n    return createTreeNode(node, textNodeSpansToTreeNodeChildren(node.spans, node));\n  }\n  if (\"items\" in node) {\n    const children = [];\n    for (let i = 0; i < node.items.length; i++) {\n      children.push(nodeToTreeNode(node.items[i]));\n    }\n    return createTreeNode(node, children);\n  }\n  return createTreeNode(node);\n};\nconst textNodeSpansToTreeNodeChildren = (spans, node, parentSpan) => {\n  if (!spans.length) {\n    return [createTextTreeNode(node.text)];\n  }\n  const mutSpans = spans.slice(0);\n  mutSpans.sort((a, b) => a.start - b.start || b.end - a.end);\n  const children = [];\n  for (let i = 0; i < mutSpans.length; i++) {\n    const span = mutSpans[i];\n    const parentSpanStart = parentSpan && parentSpan.start || 0;\n    const spanStart = span.start - parentSpanStart;\n    const spanEnd = span.end - parentSpanStart;\n    const text = node.text.slice(spanStart, spanEnd);\n    const childSpans = [];\n    for (let j = i; j < mutSpans.length; j++) {\n      const siblingSpan = mutSpans[j];\n      if (siblingSpan !== span) {\n        if (siblingSpan.start >= span.start && siblingSpan.end <= span.end) {\n          childSpans.push(siblingSpan);\n          mutSpans.splice(j, 1);\n          j--;\n        } else if (siblingSpan.start < span.end && siblingSpan.end > span.start) {\n          childSpans.push({\n            ...siblingSpan,\n            end: span.end\n          });\n          mutSpans[j] = {\n            ...siblingSpan,\n            start: span.end\n          };\n        }\n      }\n    }\n    if (i === 0 && spanStart > 0) {\n      children.push(createTextTreeNode(node.text.slice(0, spanStart)));\n    }\n    const spanWithText = {\n      ...span,\n      text\n    };\n    children.push(createTreeNode(spanWithText, textNodeSpansToTreeNodeChildren(childSpans, {\n      ...node,\n      text\n    }, span)));\n    if (spanEnd < node.text.length) {\n      children.push(createTextTreeNode(node.text.slice(spanEnd, mutSpans[i + 1] ? mutSpans[i + 1].start - parentSpanStart : void 0)));\n    }\n  }\n  return children;\n};\nexport { asTree };","map":{"version":3,"names":["uuid","i","toString","asTree","nodes","preparedNodes","prepareNodes","children","length","push","nodeToTreeNode","key","createTreeNode","node","arguments","undefined","type","text","createTextTreeNode","RichTextNodeType","span","spans","mutNodes","slice","listItem","oListItem","items","splice","list","oList","textNodeSpansToTreeNodeChildren","parentSpan","mutSpans","sort","a","b","start","end","parentSpanStart","spanStart","spanEnd","childSpans","j","siblingSpan","spanWithText"],"sources":["E:\\Aarhat Iserv - E-commerce\\new\\ariz\\Frontend\\node_modules\\@prismicio\\src\\asTree.ts"],"sourcesContent":["import {\n\tRichTextNodeType,\n\tRTAnyNode,\n\tRTBlockNode,\n\tRTInlineNode,\n\tRTListItemNode,\n\tRTNode,\n\tRTOListItemNode,\n\tRTTextNode,\n} from \"@prismicio/types\";\nimport { Tree, TreeNode } from \"./types\";\n\nconst uuid = (): string => {\n\treturn (++uuid.i).toString();\n};\nuuid.i = 0;\n\n/**\n * Parses a rich text or title field into a tree\n *\n * @remarks\n * This is a low level helper mainly intended to be used by higher level\n * packages. Most users aren't expected to this function directly.\n * @param nodes - A rich text or title field from Prismic\n *\n * @returns Tree from given rich text or title field\n */\nexport const asTree = (nodes: RTNode[]): Tree => {\n\tconst preparedNodes = prepareNodes(nodes);\n\n\tconst children: TreeNode[] = [];\n\tfor (let i = 0; i < preparedNodes.length; i++) {\n\t\tchildren.push(nodeToTreeNode(preparedNodes[i]));\n\t}\n\n\treturn {\n\t\tkey: uuid(),\n\t\tchildren,\n\t};\n};\n\nconst createTreeNode = (\n\tnode: RTAnyNode,\n\tchildren: TreeNode[] = [],\n): TreeNode => {\n\treturn {\n\t\tkey: uuid(),\n\t\ttype: node.type,\n\t\ttext: \"text\" in node ? node.text : undefined,\n\t\tnode,\n\t\tchildren,\n\t};\n};\n\nconst createTextTreeNode = (text: string): TreeNode => {\n\treturn createTreeNode({\n\t\ttype: RichTextNodeType.span,\n\t\ttext,\n\t\tspans: [],\n\t});\n};\n\nconst prepareNodes = (nodes: RTNode[]): RTBlockNode[] => {\n\tconst mutNodes: RTBlockNode[] = nodes.slice(0);\n\n\tfor (let i = 0; i < mutNodes.length; i++) {\n\t\tconst node = mutNodes[i];\n\n\t\tif (\n\t\t\tnode.type === RichTextNodeType.listItem ||\n\t\t\tnode.type === RichTextNodeType.oListItem\n\t\t) {\n\t\t\tconst items: (RTListItemNode | RTOListItemNode)[] = [\n\t\t\t\tnode as RTListItemNode | RTOListItemNode,\n\t\t\t];\n\n\t\t\twhile (mutNodes[i + 1] && mutNodes[i + 1].type === node.type) {\n\t\t\t\titems.push(mutNodes[i + 1] as RTListItemNode | RTOListItemNode);\n\t\t\t\tmutNodes.splice(i, 1);\n\t\t\t}\n\n\t\t\tif (node.type === RichTextNodeType.listItem) {\n\t\t\t\tmutNodes[i] = {\n\t\t\t\t\ttype: RichTextNodeType.list,\n\t\t\t\t\titems: items as RTListItemNode[],\n\t\t\t\t};\n\t\t\t} else {\n\t\t\t\tmutNodes[i] = {\n\t\t\t\t\ttype: RichTextNodeType.oList,\n\t\t\t\t\titems: items as RTOListItemNode[],\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\t}\n\n\treturn mutNodes;\n};\n\nconst nodeToTreeNode = (node: RTBlockNode): TreeNode => {\n\tif (\"text\" in node) {\n\t\treturn createTreeNode(\n\t\t\tnode,\n\t\t\ttextNodeSpansToTreeNodeChildren(node.spans, node),\n\t\t);\n\t}\n\n\tif (\"items\" in node) {\n\t\tconst children: TreeNode[] = [];\n\t\tfor (let i = 0; i < node.items.length; i++) {\n\t\t\tchildren.push(nodeToTreeNode(node.items[i]));\n\t\t}\n\n\t\treturn createTreeNode(node, children);\n\t}\n\n\treturn createTreeNode(node);\n};\n\nconst textNodeSpansToTreeNodeChildren = (\n\tspans: RTInlineNode[],\n\tnode: RTTextNode,\n\tparentSpan?: RTInlineNode,\n): TreeNode[] => {\n\tif (!spans.length) {\n\t\treturn [createTextTreeNode(node.text)];\n\t}\n\n\tconst mutSpans: RTInlineNode[] = spans.slice(0);\n\n\t// Sort spans using the following criteria:\n\t//\n\t//   1. By start index (ascending)\n\t//   2. If start indices are equal, by end index (descending)\n\t//\n\t// If start and end indices of more than one span are equal, use what\n\t// the API gives without modifications.\n\t//\n\t// Sorting using this algorithm ensures proper detection of child\n\t// spans.\n\tmutSpans.sort((a, b) => a.start - b.start || b.end - a.end);\n\n\tconst children: TreeNode[] = [];\n\n\tfor (let i = 0; i < mutSpans.length; i++) {\n\t\tconst span = mutSpans[i];\n\t\tconst parentSpanStart = (parentSpan && parentSpan.start) || 0;\n\t\tconst spanStart = span.start - parentSpanStart;\n\t\tconst spanEnd = span.end - parentSpanStart;\n\t\tconst text = node.text.slice(spanStart, spanEnd);\n\n\t\tconst childSpans: RTInlineNode[] = [];\n\t\tfor (let j = i; j < mutSpans.length; j++) {\n\t\t\tconst siblingSpan = mutSpans[j];\n\n\t\t\tif (siblingSpan !== span) {\n\t\t\t\tif (siblingSpan.start >= span.start && siblingSpan.end <= span.end) {\n\t\t\t\t\tchildSpans.push(siblingSpan);\n\t\t\t\t\tmutSpans.splice(j, 1);\n\t\t\t\t\tj--;\n\t\t\t\t} else if (\n\t\t\t\t\tsiblingSpan.start < span.end &&\n\t\t\t\t\tsiblingSpan.end > span.start\n\t\t\t\t) {\n\t\t\t\t\tchildSpans.push({\n\t\t\t\t\t\t...siblingSpan,\n\t\t\t\t\t\tend: span.end,\n\t\t\t\t\t});\n\t\t\t\t\tmutSpans[j] = {\n\t\t\t\t\t\t...siblingSpan,\n\t\t\t\t\t\tstart: span.end,\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (i === 0 && spanStart > 0) {\n\t\t\tchildren.push(createTextTreeNode(node.text.slice(0, spanStart)));\n\t\t}\n\n\t\tconst spanWithText = { ...span, text };\n\t\tchildren.push(\n\t\t\tcreateTreeNode(\n\t\t\t\tspanWithText,\n\t\t\t\ttextNodeSpansToTreeNodeChildren(\n\t\t\t\t\tchildSpans,\n\t\t\t\t\t{\n\t\t\t\t\t\t...node,\n\t\t\t\t\t\ttext,\n\t\t\t\t\t},\n\t\t\t\t\tspan,\n\t\t\t\t),\n\t\t\t),\n\t\t);\n\n\t\tif (spanEnd < node.text.length) {\n\t\t\tchildren.push(\n\t\t\t\tcreateTextTreeNode(\n\t\t\t\t\tnode.text.slice(\n\t\t\t\t\t\tspanEnd,\n\t\t\t\t\t\tmutSpans[i + 1]\n\t\t\t\t\t\t\t? mutSpans[i + 1].start - parentSpanStart\n\t\t\t\t\t\t\t: undefined,\n\t\t\t\t\t),\n\t\t\t\t),\n\t\t\t);\n\t\t}\n\t}\n\n\treturn children;\n};\n"],"mappings":";AAYA,MAAMA,IAAA,GAAOA,CAAA,KAAa;EACjB,UAAEA,IAAA,CAAKC,CAAA,EAAGC,QAAA,CAAQ;AAC3B;AACAF,IAAA,CAAKC,CAAA,GAAI;AAYI,MAAAE,MAAA,GAAUC,KAAA,IAAyB;EACzC,MAAAC,aAAA,GAAgBC,YAAA,CAAaF,KAAK;EAExC,MAAMG,QAAA,GAAuB;EAC7B,SAASN,CAAA,GAAI,GAAGA,CAAA,GAAII,aAAA,CAAcG,MAAA,EAAQP,CAAA,IAAK;IAC9CM,QAAA,CAASE,IAAA,CAAKC,cAAA,CAAeL,aAAA,CAAcJ,CAAC,CAAC,CAAC;EAC9C;EAEM;IACNU,GAAA,EAAKX,IAAA,CAAM;IACXO;EAAA;AAEF;AAEA,MAAMK,cAAA,GAAiB,SAAAA,CACtBC,IAAA,EAEa;EAAA,IADbN,QAAA,GAAAO,SAAA,CAAAN,MAAA,QAAAM,SAAA,QAAAC,SAAA,GAAAD,SAAA,MAAuB;EAEhB;IACNH,GAAA,EAAKX,IAAA,CAAM;IACXgB,IAAA,EAAMH,IAAA,CAAKG,IAAA;IACXC,IAAA,EAAM,UAAUJ,IAAA,GAAOA,IAAA,CAAKI,IAAA,GAAO;IACnCJ,IAAA;IACAN;EAAA;AAEF;AAEA,MAAMW,kBAAA,GAAsBD,IAAA,IAA0B;EACrD,OAAOL,cAAA,CAAe;IACrBI,IAAA,EAAMG,gBAAA,CAAiBC,IAAA;IACvBH,IAAA;IACAI,KAAA,EAAO;EAAE,CACT;AACF;AAEA,MAAMf,YAAA,GAAgBF,KAAA,IAAkC;EACjD,MAAAkB,QAAA,GAA0BlB,KAAA,CAAMmB,KAAA,CAAM,CAAC;EAE7C,SAAStB,CAAA,GAAI,GAAGA,CAAA,GAAIqB,QAAA,CAASd,MAAA,EAAQP,CAAA,IAAK;IACnC,MAAAY,IAAA,GAAOS,QAAA,CAASrB,CAAC;IAEvB,IACCY,IAAA,CAAKG,IAAA,KAASG,gBAAA,CAAiBK,QAAA,IAC/BX,IAAA,CAAKG,IAAA,KAASG,gBAAA,CAAiBM,SAAA,EAC9B;MACD,MAAMC,KAAA,GAA8C,CACnDb,IAAA;MAGM,OAAAS,QAAA,CAASrB,CAAA,GAAI,CAAC,KAAKqB,QAAA,CAASrB,CAAA,GAAI,CAAC,EAAEe,IAAA,KAASH,IAAA,CAAKG,IAAA,EAAM;QAC7DU,KAAA,CAAMjB,IAAA,CAAKa,QAAA,CAASrB,CAAA,GAAI,CAAC,CAAqC;QACrDqB,QAAA,CAAAK,MAAA,CAAO1B,CAAA,EAAG,CAAC;MACpB;MAEG,IAAAY,IAAA,CAAKG,IAAA,KAASG,gBAAA,CAAiBK,QAAA,EAAU;QAC5CF,QAAA,CAASrB,CAAC,IAAI;UACbe,IAAA,EAAMG,gBAAA,CAAiBS,IAAA;UACvBF;QAAA;MAAA,OAEK;QACNJ,QAAA,CAASrB,CAAC,IAAI;UACbe,IAAA,EAAMG,gBAAA,CAAiBU,KAAA;UACvBH;QAAA;MAED;IACD;EACD;EAEM,OAAAJ,QAAA;AACR;AAEA,MAAMZ,cAAA,GAAkBG,IAAA,IAA+B;EACtD,IAAI,UAAUA,IAAA,EAAM;IACnB,OAAOD,cAAA,CACNC,IAAA,EACAiB,+BAAA,CAAgCjB,IAAA,CAAKQ,KAAA,EAAOR,IAAI,CAAC;EAElD;EAED,IAAI,WAAWA,IAAA,EAAM;IACpB,MAAMN,QAAA,GAAuB;IAC7B,SAASN,CAAA,GAAI,GAAGA,CAAA,GAAIY,IAAA,CAAKa,KAAA,CAAMlB,MAAA,EAAQP,CAAA,IAAK;MAC3CM,QAAA,CAASE,IAAA,CAAKC,cAAA,CAAeG,IAAA,CAAKa,KAAA,CAAMzB,CAAC,CAAC,CAAC;IAC3C;IAEM,OAAAW,cAAA,CAAeC,IAAA,EAAMN,QAAQ;EACpC;EAED,OAAOK,cAAA,CAAeC,IAAI;AAC3B;AAEA,MAAMiB,+BAAA,GAAkCA,CACvCT,KAAA,EACAR,IAAA,EACAkB,UAAA,KACe;EACX,KAACV,KAAA,CAAMb,MAAA,EAAQ;IAClB,OAAO,CAACU,kBAAA,CAAmBL,IAAA,CAAKI,IAAI,CAAC;EACrC;EAEK,MAAAe,QAAA,GAA2BX,KAAA,CAAME,KAAA,CAAM,CAAC;EAYrCS,QAAA,CAAAC,IAAA,CAAK,CAACC,CAAA,EAAGC,CAAA,KAAMD,CAAA,CAAEE,KAAA,GAAQD,CAAA,CAAEC,KAAA,IAASD,CAAA,CAAEE,GAAA,GAAMH,CAAA,CAAEG,GAAG;EAE1D,MAAM9B,QAAA,GAAuB;EAE7B,SAASN,CAAA,GAAI,GAAGA,CAAA,GAAI+B,QAAA,CAASxB,MAAA,EAAQP,CAAA,IAAK;IACnC,MAAAmB,IAAA,GAAOY,QAAA,CAAS/B,CAAC;IACjB,MAAAqC,eAAA,GAAmBP,UAAA,IAAcA,UAAA,CAAWK,KAAA,IAAU;IACtD,MAAAG,SAAA,GAAYnB,IAAA,CAAKgB,KAAA,GAAQE,eAAA;IACzB,MAAAE,OAAA,GAAUpB,IAAA,CAAKiB,GAAA,GAAMC,eAAA;IAC3B,MAAMrB,IAAA,GAAOJ,IAAA,CAAKI,IAAA,CAAKM,KAAA,CAAMgB,SAAA,EAAWC,OAAO;IAE/C,MAAMC,UAAA,GAA6B;IACnC,SAASC,CAAA,GAAIzC,CAAA,EAAGyC,CAAA,GAAIV,QAAA,CAASxB,MAAA,EAAQkC,CAAA,IAAK;MACnC,MAAAC,WAAA,GAAcX,QAAA,CAASU,CAAC;MAE9B,IAAIC,WAAA,KAAgBvB,IAAA,EAAM;QACzB,IAAIuB,WAAA,CAAYP,KAAA,IAAShB,IAAA,CAAKgB,KAAA,IAASO,WAAA,CAAYN,GAAA,IAAOjB,IAAA,CAAKiB,GAAA,EAAK;UACnEI,UAAA,CAAWhC,IAAA,CAAKkC,WAAW;UAClBX,QAAA,CAAAL,MAAA,CAAOe,CAAA,EAAG,CAAC;UACpBA,CAAA;QAAA,WAEAC,WAAA,CAAYP,KAAA,GAAQhB,IAAA,CAAKiB,GAAA,IACzBM,WAAA,CAAYN,GAAA,GAAMjB,IAAA,CAAKgB,KAAA,EACtB;UACDK,UAAA,CAAWhC,IAAA,CAAK;YACf,GAAGkC,WAAA;YACHN,GAAA,EAAKjB,IAAA,CAAKiB;UAAA,CACV;UACDL,QAAA,CAASU,CAAC,IAAI;YACb,GAAGC,WAAA;YACHP,KAAA,EAAOhB,IAAA,CAAKiB;UAAA;QAEb;MACD;IACD;IAEG,IAAApC,CAAA,KAAM,KAAKsC,SAAA,GAAY,GAAG;MACpBhC,QAAA,CAAAE,IAAA,CAAKS,kBAAA,CAAmBL,IAAA,CAAKI,IAAA,CAAKM,KAAA,CAAM,GAAGgB,SAAS,CAAC,CAAC;IAC/D;IAED,MAAMK,YAAA,GAAe;MAAE,GAAGxB,IAAA;MAAMH;IAAA;IAChCV,QAAA,CAASE,IAAA,CACRG,cAAA,CACCgC,YAAA,EACAd,+BAAA,CACCW,UAAA,EACA;MACC,GAAG5B,IAAA;MACHI;IAAA,GAEDG,IAAI,CACJ,CACD;IAGE,IAAAoB,OAAA,GAAU3B,IAAA,CAAKI,IAAA,CAAKT,MAAA,EAAQ;MAC/BD,QAAA,CAASE,IAAA,CACRS,kBAAA,CACCL,IAAA,CAAKI,IAAA,CAAKM,KAAA,CACTiB,OAAA,EACAR,QAAA,CAAS/B,CAAA,GAAI,CAAC,IACX+B,QAAA,CAAS/B,CAAA,GAAI,CAAC,EAAEmC,KAAA,GAAQE,eAAA,GACxB,MAAS,CACZ,CACD;IAEF;EACD;EAEM,OAAA/B,QAAA;AACR"},"metadata":{},"sourceType":"module","externalDependencies":[]}