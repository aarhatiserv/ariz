{"ast":null,"code":"import _objectSpread from \"E:/Aarhat Iserv - E-commerce/new/ariz/Frontend/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport { RichTextNodeType } from \"@prismicio/types\";\nvar uuid = function uuid() {\n  return (++uuid.i).toString();\n};\nuuid.i = 0;\nvar asTree = function asTree(nodes) {\n  var preparedNodes = prepareNodes(nodes);\n  var children = [];\n  for (var i = 0; i < preparedNodes.length; i++) {\n    children.push(nodeToTreeNode(preparedNodes[i]));\n  }\n  return {\n    key: uuid(),\n    children: children\n  };\n};\nvar createTreeNode = function createTreeNode(node) {\n  var children = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n  return {\n    key: uuid(),\n    type: node.type,\n    text: \"text\" in node ? node.text : void 0,\n    node: node,\n    children: children\n  };\n};\nvar createTextTreeNode = function createTextTreeNode(text) {\n  return createTreeNode({\n    type: RichTextNodeType.span,\n    text: text,\n    spans: []\n  });\n};\nvar prepareNodes = function prepareNodes(nodes) {\n  var mutNodes = nodes.slice(0);\n  for (var i = 0; i < mutNodes.length; i++) {\n    var node = mutNodes[i];\n    if (node.type === RichTextNodeType.listItem || node.type === RichTextNodeType.oListItem) {\n      var items = [node];\n      while (mutNodes[i + 1] && mutNodes[i + 1].type === node.type) {\n        items.push(mutNodes[i + 1]);\n        mutNodes.splice(i, 1);\n      }\n      if (node.type === RichTextNodeType.listItem) {\n        mutNodes[i] = {\n          type: RichTextNodeType.list,\n          items: items\n        };\n      } else {\n        mutNodes[i] = {\n          type: RichTextNodeType.oList,\n          items: items\n        };\n      }\n    }\n  }\n  return mutNodes;\n};\nvar nodeToTreeNode = function nodeToTreeNode(node) {\n  if (\"text\" in node) {\n    return createTreeNode(node, textNodeSpansToTreeNodeChildren(node.spans, node));\n  }\n  if (\"items\" in node) {\n    var children = [];\n    for (var i = 0; i < node.items.length; i++) {\n      children.push(nodeToTreeNode(node.items[i]));\n    }\n    return createTreeNode(node, children);\n  }\n  return createTreeNode(node);\n};\nvar textNodeSpansToTreeNodeChildren = function textNodeSpansToTreeNodeChildren(spans, node, parentSpan) {\n  if (!spans.length) {\n    return [createTextTreeNode(node.text)];\n  }\n  var mutSpans = spans.slice(0);\n  mutSpans.sort(function (a, b) {\n    return a.start - b.start || b.end - a.end;\n  });\n  var children = [];\n  for (var i = 0; i < mutSpans.length; i++) {\n    var span = mutSpans[i];\n    var parentSpanStart = parentSpan && parentSpan.start || 0;\n    var spanStart = span.start - parentSpanStart;\n    var spanEnd = span.end - parentSpanStart;\n    var text = node.text.slice(spanStart, spanEnd);\n    var childSpans = [];\n    for (var j = i; j < mutSpans.length; j++) {\n      var siblingSpan = mutSpans[j];\n      if (siblingSpan !== span) {\n        if (siblingSpan.start >= span.start && siblingSpan.end <= span.end) {\n          childSpans.push(siblingSpan);\n          mutSpans.splice(j, 1);\n          j--;\n        } else if (siblingSpan.start < span.end && siblingSpan.end > span.start) {\n          childSpans.push(_objectSpread(_objectSpread({}, siblingSpan), {}, {\n            end: span.end\n          }));\n          mutSpans[j] = _objectSpread(_objectSpread({}, siblingSpan), {}, {\n            start: span.end\n          });\n        }\n      }\n    }\n    if (i === 0 && spanStart > 0) {\n      children.push(createTextTreeNode(node.text.slice(0, spanStart)));\n    }\n    var spanWithText = _objectSpread(_objectSpread({}, span), {}, {\n      text: text\n    });\n    children.push(createTreeNode(spanWithText, textNodeSpansToTreeNodeChildren(childSpans, _objectSpread(_objectSpread({}, node), {}, {\n      text: text\n    }), span)));\n    if (spanEnd < node.text.length) {\n      children.push(createTextTreeNode(node.text.slice(spanEnd, mutSpans[i + 1] ? mutSpans[i + 1].start - parentSpanStart : void 0)));\n    }\n  }\n  return children;\n};\nexport { asTree };","map":{"version":3,"names":["uuid","i","toString","asTree","nodes","preparedNodes","prepareNodes","children","length","push","nodeToTreeNode","key","createTreeNode","node","arguments","undefined","type","text","createTextTreeNode","RichTextNodeType","span","spans","mutNodes","slice","listItem","oListItem","items","splice","list","oList","textNodeSpansToTreeNodeChildren","parentSpan","mutSpans","sort","a","b","start","end","parentSpanStart","spanStart","spanEnd","childSpans","j","siblingSpan","_objectSpread","spanWithText"],"sources":["E:\\Aarhat Iserv - E-commerce\\new\\ariz\\Frontend\\node_modules\\@prismicio\\src\\asTree.ts"],"sourcesContent":["import {\n\tRichTextNodeType,\n\tRTAnyNode,\n\tRTBlockNode,\n\tRTInlineNode,\n\tRTListItemNode,\n\tRTNode,\n\tRTOListItemNode,\n\tRTTextNode,\n} from \"@prismicio/types\";\nimport { Tree, TreeNode } from \"./types\";\n\nconst uuid = (): string => {\n\treturn (++uuid.i).toString();\n};\nuuid.i = 0;\n\n/**\n * Parses a rich text or title field into a tree\n *\n * @remarks\n * This is a low level helper mainly intended to be used by higher level\n * packages. Most users aren't expected to this function directly.\n * @param nodes - A rich text or title field from Prismic\n *\n * @returns Tree from given rich text or title field\n */\nexport const asTree = (nodes: RTNode[]): Tree => {\n\tconst preparedNodes = prepareNodes(nodes);\n\n\tconst children: TreeNode[] = [];\n\tfor (let i = 0; i < preparedNodes.length; i++) {\n\t\tchildren.push(nodeToTreeNode(preparedNodes[i]));\n\t}\n\n\treturn {\n\t\tkey: uuid(),\n\t\tchildren,\n\t};\n};\n\nconst createTreeNode = (\n\tnode: RTAnyNode,\n\tchildren: TreeNode[] = [],\n): TreeNode => {\n\treturn {\n\t\tkey: uuid(),\n\t\ttype: node.type,\n\t\ttext: \"text\" in node ? node.text : undefined,\n\t\tnode,\n\t\tchildren,\n\t};\n};\n\nconst createTextTreeNode = (text: string): TreeNode => {\n\treturn createTreeNode({\n\t\ttype: RichTextNodeType.span,\n\t\ttext,\n\t\tspans: [],\n\t});\n};\n\nconst prepareNodes = (nodes: RTNode[]): RTBlockNode[] => {\n\tconst mutNodes: RTBlockNode[] = nodes.slice(0);\n\n\tfor (let i = 0; i < mutNodes.length; i++) {\n\t\tconst node = mutNodes[i];\n\n\t\tif (\n\t\t\tnode.type === RichTextNodeType.listItem ||\n\t\t\tnode.type === RichTextNodeType.oListItem\n\t\t) {\n\t\t\tconst items: (RTListItemNode | RTOListItemNode)[] = [\n\t\t\t\tnode as RTListItemNode | RTOListItemNode,\n\t\t\t];\n\n\t\t\twhile (mutNodes[i + 1] && mutNodes[i + 1].type === node.type) {\n\t\t\t\titems.push(mutNodes[i + 1] as RTListItemNode | RTOListItemNode);\n\t\t\t\tmutNodes.splice(i, 1);\n\t\t\t}\n\n\t\t\tif (node.type === RichTextNodeType.listItem) {\n\t\t\t\tmutNodes[i] = {\n\t\t\t\t\ttype: RichTextNodeType.list,\n\t\t\t\t\titems: items as RTListItemNode[],\n\t\t\t\t};\n\t\t\t} else {\n\t\t\t\tmutNodes[i] = {\n\t\t\t\t\ttype: RichTextNodeType.oList,\n\t\t\t\t\titems: items as RTOListItemNode[],\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\t}\n\n\treturn mutNodes;\n};\n\nconst nodeToTreeNode = (node: RTBlockNode): TreeNode => {\n\tif (\"text\" in node) {\n\t\treturn createTreeNode(\n\t\t\tnode,\n\t\t\ttextNodeSpansToTreeNodeChildren(node.spans, node),\n\t\t);\n\t}\n\n\tif (\"items\" in node) {\n\t\tconst children: TreeNode[] = [];\n\t\tfor (let i = 0; i < node.items.length; i++) {\n\t\t\tchildren.push(nodeToTreeNode(node.items[i]));\n\t\t}\n\n\t\treturn createTreeNode(node, children);\n\t}\n\n\treturn createTreeNode(node);\n};\n\nconst textNodeSpansToTreeNodeChildren = (\n\tspans: RTInlineNode[],\n\tnode: RTTextNode,\n\tparentSpan?: RTInlineNode,\n): TreeNode[] => {\n\tif (!spans.length) {\n\t\treturn [createTextTreeNode(node.text)];\n\t}\n\n\tconst mutSpans: RTInlineNode[] = spans.slice(0);\n\n\t// Sort spans using the following criteria:\n\t//\n\t//   1. By start index (ascending)\n\t//   2. If start indices are equal, by end index (descending)\n\t//\n\t// If start and end indices of more than one span are equal, use what\n\t// the API gives without modifications.\n\t//\n\t// Sorting using this algorithm ensures proper detection of child\n\t// spans.\n\tmutSpans.sort((a, b) => a.start - b.start || b.end - a.end);\n\n\tconst children: TreeNode[] = [];\n\n\tfor (let i = 0; i < mutSpans.length; i++) {\n\t\tconst span = mutSpans[i];\n\t\tconst parentSpanStart = (parentSpan && parentSpan.start) || 0;\n\t\tconst spanStart = span.start - parentSpanStart;\n\t\tconst spanEnd = span.end - parentSpanStart;\n\t\tconst text = node.text.slice(spanStart, spanEnd);\n\n\t\tconst childSpans: RTInlineNode[] = [];\n\t\tfor (let j = i; j < mutSpans.length; j++) {\n\t\t\tconst siblingSpan = mutSpans[j];\n\n\t\t\tif (siblingSpan !== span) {\n\t\t\t\tif (siblingSpan.start >= span.start && siblingSpan.end <= span.end) {\n\t\t\t\t\tchildSpans.push(siblingSpan);\n\t\t\t\t\tmutSpans.splice(j, 1);\n\t\t\t\t\tj--;\n\t\t\t\t} else if (\n\t\t\t\t\tsiblingSpan.start < span.end &&\n\t\t\t\t\tsiblingSpan.end > span.start\n\t\t\t\t) {\n\t\t\t\t\tchildSpans.push({\n\t\t\t\t\t\t...siblingSpan,\n\t\t\t\t\t\tend: span.end,\n\t\t\t\t\t});\n\t\t\t\t\tmutSpans[j] = {\n\t\t\t\t\t\t...siblingSpan,\n\t\t\t\t\t\tstart: span.end,\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (i === 0 && spanStart > 0) {\n\t\t\tchildren.push(createTextTreeNode(node.text.slice(0, spanStart)));\n\t\t}\n\n\t\tconst spanWithText = { ...span, text };\n\t\tchildren.push(\n\t\t\tcreateTreeNode(\n\t\t\t\tspanWithText,\n\t\t\t\ttextNodeSpansToTreeNodeChildren(\n\t\t\t\t\tchildSpans,\n\t\t\t\t\t{\n\t\t\t\t\t\t...node,\n\t\t\t\t\t\ttext,\n\t\t\t\t\t},\n\t\t\t\t\tspan,\n\t\t\t\t),\n\t\t\t),\n\t\t);\n\n\t\tif (spanEnd < node.text.length) {\n\t\t\tchildren.push(\n\t\t\t\tcreateTextTreeNode(\n\t\t\t\t\tnode.text.slice(\n\t\t\t\t\t\tspanEnd,\n\t\t\t\t\t\tmutSpans[i + 1]\n\t\t\t\t\t\t\t? mutSpans[i + 1].start - parentSpanStart\n\t\t\t\t\t\t\t: undefined,\n\t\t\t\t\t),\n\t\t\t\t),\n\t\t\t);\n\t\t}\n\t}\n\n\treturn children;\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}