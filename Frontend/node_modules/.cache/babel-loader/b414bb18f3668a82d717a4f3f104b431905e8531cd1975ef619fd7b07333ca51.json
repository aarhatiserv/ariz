{"ast":null,"code":"import _toConsumableArray from \"E:/Aarhat Iserv - E-commerce/new/ariz/Frontend/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport _objectWithoutProperties from \"E:/Aarhat Iserv - E-commerce/new/ariz/Frontend/node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js\";\nimport _objectSpread from \"E:/Aarhat Iserv - E-commerce/new/ariz/Frontend/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _regeneratorRuntime from \"E:/Aarhat Iserv - E-commerce/new/ariz/Frontend/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _asyncToGenerator from \"E:/Aarhat Iserv - E-commerce/new/ariz/Frontend/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport _classCallCheck from \"E:/Aarhat Iserv - E-commerce/new/ariz/Frontend/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"E:/Aarhat Iserv - E-commerce/new/ariz/Frontend/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nvar _excluded = [\"limit\"],\n  _excluded2 = [\"signal\", \"fetchOptions\"];\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = function __defNormalProp(obj, key, value) {\n  return key in obj ? __defProp(obj, key, {\n    enumerable: true,\n    configurable: true,\n    writable: true,\n    value: value\n  }) : obj[key] = value;\n};\nvar __publicField = function __publicField(obj, key, value) {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nimport { appendFilters } from \"./lib/appendFilters.js\";\nimport { castThunk } from \"./lib/castThunk.js\";\nimport { devMsg } from \"./lib/devMsg.js\";\nimport { everyTagFilter } from \"./lib/everyTagFilter.js\";\nimport { findMasterRef } from \"./lib/findMasterRef.js\";\nimport { findRefByID } from \"./lib/findRefByID.js\";\nimport { findRefByLabel } from \"./lib/findRefByLabel.js\";\nimport { getPreviewCookie } from \"./lib/getPreviewCookie.js\";\nimport { minifyGraphQLQuery } from \"./lib/minifyGraphQLQuery.js\";\nimport { someTagsFilter } from \"./lib/someTagsFilter.js\";\nimport { typeFilter } from \"./lib/typeFilter.js\";\nimport { ForbiddenError } from \"./errors/ForbiddenError.js\";\nimport { NotFoundError } from \"./errors/NotFoundError.js\";\nimport { ParsingError } from \"./errors/ParsingError.js\";\nimport { PrismicError } from \"./errors/PrismicError.js\";\nimport { asLink } from \"./helpers/asLink.js\";\nimport { buildQueryURL as _buildQueryURL } from \"./buildQueryURL.js\";\nimport { filter } from \"./filter.js\";\nimport { getRepositoryEndpoint } from \"./getRepositoryEndpoint.js\";\nimport { getRepositoryName } from \"./getRepositoryName.js\";\nimport { isRepositoryEndpoint } from \"./isRepositoryEndpoint.js\";\nvar MAX_PAGE_SIZE = 100;\nvar REPOSITORY_CACHE_TTL = 5e3;\nvar GET_ALL_QUERY_DELAY = 500;\nvar RefStateMode;\n(function (RefStateMode2) {\n  RefStateMode2[\"Master\"] = \"Master\";\n  RefStateMode2[\"ReleaseID\"] = \"ReleaseID\";\n  RefStateMode2[\"ReleaseLabel\"] = \"ReleaseLabel\";\n  RefStateMode2[\"Manual\"] = \"Manual\";\n})(RefStateMode || (RefStateMode = {}));\nvar createClient = function createClient(repositoryNameOrEndpoint, options) {\n  return new Client(repositoryNameOrEndpoint, options);\n};\nvar Client = /*#__PURE__*/function () {\n  /**\n   * Creates a Prismic client that can be used to query a repository.\n   *\n   * If used in an environment where a global `fetch` function is unavailable,\n   * such as Node.js, the `fetch` option must be provided as part of the\n   * `options` parameter.\n   *\n   * @param repositoryNameOrEndpoint - The Prismic repository name or full Rest\n   *   API V2 endpoint for the repository.\n   * @param options - Configuration that determines how content will be queried\n   *   from the Prismic repository.\n   *\n   * @returns A client that can query content from the repository.\n   */\n  function Client(repositoryNameOrEndpoint) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    _classCallCheck(this, Client);\n    /**\n     * The Prismic REST API V2 endpoint for the repository (use\n     * `prismic.getRepositoryEndpoint` for the default endpoint).\n     */\n    __publicField(this, \"endpoint\");\n    /**\n     * The secure token for accessing the API (only needed if your repository is\n     * set to private).\n     *\n     * {@link https://user-guides.prismic.io/en/articles/1036153-generating-an-access-token}\n     */\n    __publicField(this, \"accessToken\");\n    /**\n     * A list of route resolver objects that define how a document's `url` field\n     * is resolved.\n     *\n     * {@link https://prismic.io/docs/route-resolver}\n     */\n    __publicField(this, \"routes\");\n    /**\n     * The `brokenRoute` option allows you to define the route populated in the\n     * `url` property for broken link or content relationship fields. A broken\n     * link is a link or content relationship field whose linked document has been\n     * unpublished or deleted.\n     *\n     * {@link https://prismic.io/docs/route-resolver}\n     */\n    __publicField(this, \"brokenRoute\");\n    /**\n     * The function used to make network requests to the Prismic REST API. In\n     * environments where a global `fetch` function does not exist, such as\n     * Node.js, this function must be provided.\n     */\n    __publicField(this, \"fetchFn\");\n    __publicField(this, \"fetchOptions\");\n    /**\n     * Default parameters that will be sent with each query. These parameters can\n     * be overridden on each query if needed.\n     */\n    __publicField(this, \"defaultParams\");\n    /**\n     * The client's ref mode state. This determines which ref is used during\n     * queries.\n     */\n    __publicField(this, \"refState\", {\n      mode: RefStateMode.Master,\n      autoPreviewsEnabled: true\n    });\n    /**\n     * Cached repository value.\n     */\n    __publicField(this, \"cachedRepository\");\n    /**\n     * Timestamp at which the cached repository data is considered stale.\n     */\n    __publicField(this, \"cachedRepositoryExpiration\", 0);\n    /**\n     * Active `fetch()` jobs keyed by URL and AbortSignal (if it exists).\n     */\n    __publicField(this, \"fetchJobs\", {});\n    if (isRepositoryEndpoint(repositoryNameOrEndpoint)) {\n      if (process.env.NODE_ENV === \"development\") {\n        if (/\\.prismic\\.io\\/(?!api\\/v2\\/?)/i.test(repositoryNameOrEndpoint)) {\n          throw new PrismicError(\"@prismicio/client only supports Prismic Rest API V2. Please provide only the repository name to the first createClient() parameter or use the getRepositoryEndpoint() helper to generate a valid Rest API V2 endpoint URL.\", void 0, void 0);\n        }\n        var hostname = new URL(repositoryNameOrEndpoint).hostname.toLowerCase();\n        if (hostname.endsWith(\".prismic.io\") && !hostname.endsWith(\".cdn.prismic.io\")) {\n          var repositoryName = getRepositoryName(repositoryNameOrEndpoint);\n          var dotCDNEndpoint = getRepositoryEndpoint(repositoryName);\n          console.warn(\"[@prismicio/client] A non-.cdn endpoint was provided to create a client with (`\".concat(repositoryNameOrEndpoint, \"`). Non-.cdn endpoints can have unexpected side-effects and cause performance issues when querying Prismic. Please convert it to the `.cdn` alternative (`\").concat(dotCDNEndpoint, \"`) or use the repository name directly instead (`\").concat(repositoryName, \"`). For more details, see \").concat(devMsg(\"endpoint-must-use-cdn\")));\n        }\n      }\n      this.endpoint = repositoryNameOrEndpoint;\n    } else {\n      this.endpoint = getRepositoryEndpoint(repositoryNameOrEndpoint);\n    }\n    this.accessToken = options.accessToken;\n    this.routes = options.routes;\n    this.brokenRoute = options.brokenRoute;\n    this.fetchOptions = options.fetchOptions;\n    this.defaultParams = options.defaultParams;\n    if (options.ref) {\n      this.queryContentFromRef(options.ref);\n    }\n    if (typeof options.fetch === \"function\") {\n      this.fetchFn = options.fetch;\n    } else if (typeof globalThis.fetch === \"function\") {\n      this.fetchFn = globalThis.fetch;\n    } else {\n      throw new PrismicError(\"A valid fetch implementation was not provided. In environments where fetch is not available (including Node.js), a fetch implementation must be provided via a polyfill or the `fetch` option.\", void 0, void 0);\n    }\n    if (this.fetchFn === globalThis.fetch) {\n      this.fetchFn = this.fetchFn.bind(globalThis);\n    }\n    this.graphQLFetch = this.graphQLFetch.bind(this);\n  }\n  /**\n   * Enables the client to automatically query content from a preview session if\n   * one is active in browser environments. This is enabled by default in the\n   * browser.\n   *\n   * For server environments, use `enableAutoPreviewsFromReq`.\n   *\n   * @example\n   *\n   * ```ts\n   * client.enableAutoPreviews();\n   * ```\n   *\n   * @see enableAutoPreviewsFromReq\n   */\n  _createClass(Client, [{\n    key: \"enableAutoPreviews\",\n    value: function enableAutoPreviews() {\n      this.refState.autoPreviewsEnabled = true;\n    }\n    /**\n     * Enables the client to automatically query content from a preview session if\n     * one is active in server environments. This is disabled by default on the\n     * server.\n     *\n     * For browser environments, use `enableAutoPreviews`.\n     *\n     * @example\n     *\n     * ```ts\n     * // In an express app\n     * app.get(\"/\", function (req, res) {\n     * \tclient.enableAutoPreviewsFromReq(req);\n     * });\n     * ```\n     *\n     * @param req - An HTTP server request object containing the request's\n     *   cookies.\n     */\n  }, {\n    key: \"enableAutoPreviewsFromReq\",\n    value: function enableAutoPreviewsFromReq(req) {\n      this.refState.httpRequest = req;\n      this.refState.autoPreviewsEnabled = true;\n    }\n    /**\n     * Disables the client from automatically querying content from a preview\n     * session if one is active.\n     *\n     * Automatic preview content querying is enabled by default unless this method\n     * is called.\n     *\n     * @example\n     *\n     * ```ts\n     * client.disableAutoPreviews();\n     * ```\n     */\n  }, {\n    key: \"disableAutoPreviews\",\n    value: function disableAutoPreviews() {\n      this.refState.autoPreviewsEnabled = false;\n    }\n    /**\n     * Queries content from the Prismic repository.\n     *\n     * @example\n     *\n     * ```ts\n     * const response = await client.get();\n     * ```\n     *\n     * @typeParam TDocument - Type of Prismic documents returned.\n     *\n     * @param params - Parameters to filter, sort, and paginate results.\n     *\n     * @returns A paginated response containing the result of the query.\n     */\n  }, {\n    key: \"get\",\n    value: function () {\n      var _get = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(params) {\n        var url;\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) switch (_context.prev = _context.next) {\n            case 0:\n              _context.next = 2;\n              return this.buildQueryURL(params);\n            case 2:\n              url = _context.sent;\n              _context.next = 5;\n              return this.fetch(url, params);\n            case 5:\n              return _context.abrupt(\"return\", _context.sent);\n            case 6:\n            case \"end\":\n              return _context.stop();\n          }\n        }, _callee, this);\n      }));\n      function get(_x) {\n        return _get.apply(this, arguments);\n      }\n      return get;\n    }()\n    /**\n     * Queries content from the Prismic repository and returns only the first\n     * result, if any.\n     *\n     * @example\n     *\n     * ```ts\n     * const document = await client.getFirst();\n     * ```\n     *\n     * @typeParam TDocument - Type of the Prismic document returned.\n     *\n     * @param params - Parameters to filter, sort, and paginate results. @returns\n     *   The first result of the query, if any.\n     */\n  }, {\n    key: \"getFirst\",\n    value: function () {\n      var _getFirst = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(params) {\n        var _a, actualParams, _ref, url, result, firstResult;\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) switch (_context2.prev = _context2.next) {\n            case 0:\n              actualParams = _objectSpread({}, params);\n              if (!(params && params.page) && !(params == null ? void 0 : params.pageSize)) {\n                actualParams.pageSize = (_ref = (_a = this.defaultParams) == null ? void 0 : _a.pageSize) !== null && _ref !== void 0 ? _ref : 1;\n              }\n              _context2.next = 4;\n              return this.buildQueryURL(actualParams);\n            case 4:\n              url = _context2.sent;\n              _context2.next = 7;\n              return this.fetch(url, params);\n            case 7:\n              result = _context2.sent;\n              firstResult = result.results[0];\n              if (!firstResult) {\n                _context2.next = 11;\n                break;\n              }\n              return _context2.abrupt(\"return\", firstResult);\n            case 11:\n              throw new PrismicError(\"No documents were returned\", url, void 0);\n            case 12:\n            case \"end\":\n              return _context2.stop();\n          }\n        }, _callee2, this);\n      }));\n      function getFirst(_x2) {\n        return _getFirst.apply(this, arguments);\n      }\n      return getFirst;\n    }()\n    /**\n     * **IMPORTANT**: Avoid using `dangerouslyGetAll` as it may be slower and\n     * require more resources than other methods. Prefer using other methods that\n     * filter by filters such as `getAllByType`.\n     *\n     * Queries content from the Prismic repository and returns all matching\n     * content. If no filters are provided, all documents will be fetched.\n     *\n     * This method may make multiple network requests to query all matching\n     * content.\n     *\n     * @example\n     *\n     * ```ts\n     * const response = await client.dangerouslyGetAll();\n     * ```\n     *\n     * @typeParam TDocument - Type of Prismic documents returned.\n     *\n     * @param params - Parameters to filter, sort, and paginate results.\n     *\n     * @returns A list of documents matching the query.\n     */\n  }, {\n    key: \"dangerouslyGetAll\",\n    value: function () {\n      var _dangerouslyGetAll = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3() {\n        var params,\n          _a,\n          _params$limit,\n          limit,\n          actualParams,\n          resolvedParams,\n          documents,\n          latestResult,\n          page,\n          _args3 = arguments;\n        return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n          while (1) switch (_context3.prev = _context3.next) {\n            case 0:\n              params = _args3.length > 0 && _args3[0] !== undefined ? _args3[0] : {};\n              _params$limit = params.limit, limit = _params$limit === void 0 ? Infinity : _params$limit, actualParams = _objectWithoutProperties(params, _excluded);\n              resolvedParams = _objectSpread(_objectSpread({}, actualParams), {}, {\n                pageSize: Math.min(limit, actualParams.pageSize || ((_a = this.defaultParams) == null ? void 0 : _a.pageSize) || MAX_PAGE_SIZE)\n              });\n              documents = [];\n            case 4:\n              if (!((!latestResult || latestResult.next_page) && documents.length < limit)) {\n                _context3.next = 15;\n                break;\n              }\n              page = latestResult ? latestResult.page + 1 : void 0;\n              _context3.next = 8;\n              return this.get(_objectSpread(_objectSpread({}, resolvedParams), {}, {\n                page: page\n              }));\n            case 8:\n              latestResult = _context3.sent;\n              documents.push.apply(documents, _toConsumableArray(latestResult.results));\n              if (!latestResult.next_page) {\n                _context3.next = 13;\n                break;\n              }\n              _context3.next = 13;\n              return new Promise(function (res) {\n                return setTimeout(res, GET_ALL_QUERY_DELAY);\n              });\n            case 13:\n              _context3.next = 4;\n              break;\n            case 15:\n              return _context3.abrupt(\"return\", documents.slice(0, limit));\n            case 16:\n            case \"end\":\n              return _context3.stop();\n          }\n        }, _callee3, this);\n      }));\n      function dangerouslyGetAll() {\n        return _dangerouslyGetAll.apply(this, arguments);\n      }\n      return dangerouslyGetAll;\n    }()\n    /**\n     * Queries a document from the Prismic repository with a specific ID.\n     *\n     * @remarks\n     * A document's UID is different from its ID. An ID is automatically generated\n     * for all documents and is made available on its `id` property. A UID is\n     * provided in the Prismic editor and is unique among all documents of its\n     * custom type.\n     * @example\n     *\n     * ```ts\n     * const document = await client.getByID(\"WW4bKScAAMAqmluX\");\n     * ```\n     *\n     * @typeParam TDocument- Type of the Prismic document returned.\n     *\n     * @param id - ID of the document.\n     * @param params - Parameters to filter, sort, and paginate the results.\n     *\n     * @returns The document with an ID matching the `id` parameter, if a matching\n     *   document exists.\n     */\n  }, {\n    key: \"getByID\",\n    value: function () {\n      var _getByID = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(id, params) {\n        return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n          while (1) switch (_context4.prev = _context4.next) {\n            case 0:\n              _context4.next = 2;\n              return this.getFirst(appendFilters(params, filter.at(\"document.id\", id)));\n            case 2:\n              return _context4.abrupt(\"return\", _context4.sent);\n            case 3:\n            case \"end\":\n              return _context4.stop();\n          }\n        }, _callee4, this);\n      }));\n      function getByID(_x3, _x4) {\n        return _getByID.apply(this, arguments);\n      }\n      return getByID;\n    }()\n    /**\n     * Queries documents from the Prismic repository with specific IDs.\n     *\n     * @remarks\n     * A document's UID is different from its ID. An ID is automatically generated\n     * for all documents and is made available on its `id` property. A UID is\n     * provided in the Prismic editor and is unique among all documents of its\n     * custom type.\n     * @example\n     *\n     * ```ts\n     * const response = await client.getByIDs([\n     * \t\"WW4bKScAAMAqmluX\",\n     * \t\"U1kTRgEAAC8A5ldS\",\n     * ]);\n     * ```\n     *\n     * @typeParam TDocument - Type of Prismic documents returned.\n     *\n     * @param ids - A list of document IDs.\n     * @param params - Parameters to filter, sort, and paginate the results.\n     *\n     * @returns A paginated response containing documents with IDs matching the\n     *   `ids` parameter.\n     */\n  }, {\n    key: \"getByIDs\",\n    value: function () {\n      var _getByIDs = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(ids, params) {\n        return _regeneratorRuntime().wrap(function _callee5$(_context5) {\n          while (1) switch (_context5.prev = _context5.next) {\n            case 0:\n              _context5.next = 2;\n              return this.get(appendFilters(params, filter.in(\"document.id\", ids)));\n            case 2:\n              return _context5.abrupt(\"return\", _context5.sent);\n            case 3:\n            case \"end\":\n              return _context5.stop();\n          }\n        }, _callee5, this);\n      }));\n      function getByIDs(_x5, _x6) {\n        return _getByIDs.apply(this, arguments);\n      }\n      return getByIDs;\n    }()\n    /**\n     * Queries all documents from the Prismic repository with specific IDs.\n     *\n     * This method may make multiple network requests to query all matching\n     * content.\n     *\n     * @remarks\n     * A document's UID is different from its ID. An ID is automatically generated\n     * for all documents and is made available on its `id` property. A UID is\n     * provided in the Prismic editor and is unique among all documents of its\n     * custom type.\n     * @example\n     *\n     * ```ts\n     * const response = await client.getAllByIDs([\n     * \t\"WW4bKScAAMAqmluX\",\n     * \t\"U1kTRgEAAC8A5ldS\",\n     * ]);\n     * ```\n     *\n     * @typeParam TDocument - Type of Prismic documents returned.\n     *\n     * @param ids - A list of document IDs.\n     * @param params - Parameters to filter, sort, and paginate the results.\n     *\n     * @returns A list of documents with IDs matching the `ids` parameter.\n     */\n  }, {\n    key: \"getAllByIDs\",\n    value: function () {\n      var _getAllByIDs = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6(ids, params) {\n        return _regeneratorRuntime().wrap(function _callee6$(_context6) {\n          while (1) switch (_context6.prev = _context6.next) {\n            case 0:\n              _context6.next = 2;\n              return this.dangerouslyGetAll(appendFilters(params, filter.in(\"document.id\", ids)));\n            case 2:\n              return _context6.abrupt(\"return\", _context6.sent);\n            case 3:\n            case \"end\":\n              return _context6.stop();\n          }\n        }, _callee6, this);\n      }));\n      function getAllByIDs(_x7, _x8) {\n        return _getAllByIDs.apply(this, arguments);\n      }\n      return getAllByIDs;\n    }()\n    /**\n     * Queries a document from the Prismic repository with a specific UID and\n     * custom type.\n     *\n     * @remarks\n     * A document's UID is different from its ID. An ID is automatically generated\n     * for all documents and is made available on its `id` property. A UID is\n     * provided in the Prismic editor and is unique among all documents of its\n     * custom type.\n     * @example\n     *\n     * ```ts\n     * const document = await client.getByUID(\"blog_post\", \"my-first-post\");\n     * ```\n     *\n     * @typeParam TDocument - Type of the Prismic document returned.\n     *\n     * @param documentType - The API ID of the document's custom type.\n     * @param uid - UID of the document.\n     * @param params - Parameters to filter, sort, and paginate the results.\n     *\n     * @returns The document with a UID matching the `uid` parameter, if a\n     *   matching document exists.\n     */\n  }, {\n    key: \"getByUID\",\n    value: function () {\n      var _getByUID = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7(documentType, uid, params) {\n        return _regeneratorRuntime().wrap(function _callee7$(_context7) {\n          while (1) switch (_context7.prev = _context7.next) {\n            case 0:\n              _context7.next = 2;\n              return this.getFirst(appendFilters(params, [typeFilter(documentType), filter.at(\"my.\".concat(documentType, \".uid\"), uid)]));\n            case 2:\n              return _context7.abrupt(\"return\", _context7.sent);\n            case 3:\n            case \"end\":\n              return _context7.stop();\n          }\n        }, _callee7, this);\n      }));\n      function getByUID(_x9, _x10, _x11) {\n        return _getByUID.apply(this, arguments);\n      }\n      return getByUID;\n    }()\n    /**\n     * Queries document from the Prismic repository with specific UIDs and Custom\n     * Type.\n     *\n     * @remarks\n     * A document's UID is different from its ID. An ID is automatically generated\n     * for all documents and is made available on its `id` property. A UID is\n     * provided in the Prismic editor and is unique among all documents of its\n     * custom type.\n     * @example\n     *\n     * ```ts\n     * const document = await client.getByUIDs(\"blog_post\", [\n     * \t\"my-first-post\",\n     * \t\"my-second-post\",\n     * ]);\n     * ```\n     *\n     * @typeParam TDocument - Type of the Prismic document returned.\n     *\n     * @param documentType - The API ID of the document's custom type.\n     * @param uids - A list of document UIDs.\n     * @param params - Parameters to filter, sort, and paginate the results.\n     *\n     * @returns A paginated response containing documents with UIDs matching the\n     *   `uids` parameter.\n     */\n  }, {\n    key: \"getByUIDs\",\n    value: function () {\n      var _getByUIDs = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee8(documentType, uids, params) {\n        return _regeneratorRuntime().wrap(function _callee8$(_context8) {\n          while (1) switch (_context8.prev = _context8.next) {\n            case 0:\n              _context8.next = 2;\n              return this.get(appendFilters(params, [typeFilter(documentType), filter.in(\"my.\".concat(documentType, \".uid\"), uids)]));\n            case 2:\n              return _context8.abrupt(\"return\", _context8.sent);\n            case 3:\n            case \"end\":\n              return _context8.stop();\n          }\n        }, _callee8, this);\n      }));\n      function getByUIDs(_x12, _x13, _x14) {\n        return _getByUIDs.apply(this, arguments);\n      }\n      return getByUIDs;\n    }()\n    /**\n     * Queries all documents from the Prismic repository with specific UIDs and\n     * custom type.\n     *\n     * This method may make multiple network requests to query all matching\n     * content.\n     *\n     * @remarks\n     * A document's UID is different from its ID. An ID is automatically generated\n     * for all documents and is made available on its `id` property. A UID is\n     * provided in the Prismic editor and is unique among all documents of its\n     * custom type.\n     * @example\n     *\n     * ```ts\n     * const response = await client.getAllByUIDs([\n     * \t\"my-first-post\",\n     * \t\"my-second-post\",\n     * ]);\n     * ```\n     *\n     * @typeParam TDocument - Type of Prismic documents returned.\n     *\n     * @param documentType - The API ID of the document's custom type.\n     * @param uids - A list of document UIDs.\n     * @param params - Parameters to filter, sort, and paginate the results.\n     *\n     * @returns A list of documents with UIDs matching the `uids` parameter.\n     */\n  }, {\n    key: \"getAllByUIDs\",\n    value: function () {\n      var _getAllByUIDs = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee9(documentType, uids, params) {\n        return _regeneratorRuntime().wrap(function _callee9$(_context9) {\n          while (1) switch (_context9.prev = _context9.next) {\n            case 0:\n              _context9.next = 2;\n              return this.dangerouslyGetAll(appendFilters(params, [typeFilter(documentType), filter.in(\"my.\".concat(documentType, \".uid\"), uids)]));\n            case 2:\n              return _context9.abrupt(\"return\", _context9.sent);\n            case 3:\n            case \"end\":\n              return _context9.stop();\n          }\n        }, _callee9, this);\n      }));\n      function getAllByUIDs(_x15, _x16, _x17) {\n        return _getAllByUIDs.apply(this, arguments);\n      }\n      return getAllByUIDs;\n    }()\n    /**\n     * Queries a singleton document from the Prismic repository for a specific\n     * custom type.\n     *\n     * @remarks\n     * A singleton document is one that is configured in Prismic to only allow one\n     * instance. For example, a repository may be configured to contain just one\n     * Settings document. This is in contrast to a repeatable custom type which\n     * allows multiple instances of itself.\n     * @example\n     *\n     * ```ts\n     * const document = await client.getSingle(\"settings\");\n     * ```\n     *\n     * @typeParam TDocument - Type of the Prismic document returned.\n     *\n     * @param documentType - The API ID of the singleton custom type.\n     * @param params - Parameters to filter, sort, and paginate the results.\n     *\n     * @returns The singleton document for the custom type, if a matching document\n     *   exists.\n     */\n  }, {\n    key: \"getSingle\",\n    value: function () {\n      var _getSingle = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee10(documentType, params) {\n        return _regeneratorRuntime().wrap(function _callee10$(_context10) {\n          while (1) switch (_context10.prev = _context10.next) {\n            case 0:\n              _context10.next = 2;\n              return this.getFirst(appendFilters(params, typeFilter(documentType)));\n            case 2:\n              return _context10.abrupt(\"return\", _context10.sent);\n            case 3:\n            case \"end\":\n              return _context10.stop();\n          }\n        }, _callee10, this);\n      }));\n      function getSingle(_x18, _x19) {\n        return _getSingle.apply(this, arguments);\n      }\n      return getSingle;\n    }()\n    /**\n     * Queries documents from the Prismic repository for a specific custom type.\n     *\n     * Use `getAllByType` instead if you need to query all documents for a\n     * specific custom type.\n     *\n     * @example\n     *\n     * ```ts\n     * const response = await client.getByType(\"blog_post\");\n     * ```\n     *\n     * @typeParam TDocument - Type of Prismic documents returned.\n     *\n     * @param documentType - The API ID of the custom type.\n     * @param params - Parameters to filter, sort, and paginate the results.\n     *\n     * @returns A paginated response containing documents of the custom type.\n     */\n  }, {\n    key: \"getByType\",\n    value: function () {\n      var _getByType = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee11(documentType, params) {\n        return _regeneratorRuntime().wrap(function _callee11$(_context11) {\n          while (1) switch (_context11.prev = _context11.next) {\n            case 0:\n              _context11.next = 2;\n              return this.get(appendFilters(params, typeFilter(documentType)));\n            case 2:\n              return _context11.abrupt(\"return\", _context11.sent);\n            case 3:\n            case \"end\":\n              return _context11.stop();\n          }\n        }, _callee11, this);\n      }));\n      function getByType(_x20, _x21) {\n        return _getByType.apply(this, arguments);\n      }\n      return getByType;\n    }()\n    /**\n     * Queries all documents from the Prismic repository for a specific Custom\n     * Type.\n     *\n     * This method may make multiple network requests to query all matching\n     * content.\n     *\n     * @example\n     *\n     * ```ts\n     * const response = await client.getByType(\"blog_post\");\n     * ```\n     *\n     * @typeParam TDocument - Type of Prismic documents returned.\n     *\n     * @param documentType - The API ID of the custom type.\n     * @param params - Parameters to filter, sort, and paginate the results.\n     *\n     * @returns A list of all documents of the custom type.\n     */\n  }, {\n    key: \"getAllByType\",\n    value: function () {\n      var _getAllByType = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee12(documentType, params) {\n        return _regeneratorRuntime().wrap(function _callee12$(_context12) {\n          while (1) switch (_context12.prev = _context12.next) {\n            case 0:\n              _context12.next = 2;\n              return this.dangerouslyGetAll(appendFilters(params, typeFilter(documentType)));\n            case 2:\n              return _context12.abrupt(\"return\", _context12.sent);\n            case 3:\n            case \"end\":\n              return _context12.stop();\n          }\n        }, _callee12, this);\n      }));\n      function getAllByType(_x22, _x23) {\n        return _getAllByType.apply(this, arguments);\n      }\n      return getAllByType;\n    }()\n    /**\n     * Queries documents from the Prismic repository with a specific tag.\n     *\n     * Use `getAllByTag` instead if you need to query all documents with a\n     * specific tag.\n     *\n     * @example\n     *\n     * ```ts\n     * const response = await client.getByTag(\"food\");\n     * ```\n     *\n     * @typeParam TDocument - Type of Prismic documents returned.\n     *\n     * @param tag - The tag that must be included on a document.\n     * @param params - Parameters to filter, sort, and paginate the results.\n     *\n     * @returns A paginated response containing documents with the tag.\n     */\n  }, {\n    key: \"getByTag\",\n    value: function () {\n      var _getByTag = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee13(tag, params) {\n        return _regeneratorRuntime().wrap(function _callee13$(_context13) {\n          while (1) switch (_context13.prev = _context13.next) {\n            case 0:\n              _context13.next = 2;\n              return this.get(appendFilters(params, someTagsFilter(tag)));\n            case 2:\n              return _context13.abrupt(\"return\", _context13.sent);\n            case 3:\n            case \"end\":\n              return _context13.stop();\n          }\n        }, _callee13, this);\n      }));\n      function getByTag(_x24, _x25) {\n        return _getByTag.apply(this, arguments);\n      }\n      return getByTag;\n    }()\n    /**\n     * Queries all documents from the Prismic repository with a specific tag.\n     *\n     * This method may make multiple network requests to query all matching\n     * content.\n     *\n     * @example\n     *\n     * ```ts\n     * const response = await client.getAllByTag(\"food\");\n     * ```\n     *\n     * @typeParam TDocument - Type of Prismic documents returned.\n     *\n     * @param tag - The tag that must be included on a document.\n     * @param params - Parameters to filter, sort, and paginate the results.\n     *\n     * @returns A list of all documents with the tag.\n     */\n  }, {\n    key: \"getAllByTag\",\n    value: function () {\n      var _getAllByTag = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee14(tag, params) {\n        return _regeneratorRuntime().wrap(function _callee14$(_context14) {\n          while (1) switch (_context14.prev = _context14.next) {\n            case 0:\n              _context14.next = 2;\n              return this.dangerouslyGetAll(appendFilters(params, someTagsFilter(tag)));\n            case 2:\n              return _context14.abrupt(\"return\", _context14.sent);\n            case 3:\n            case \"end\":\n              return _context14.stop();\n          }\n        }, _callee14, this);\n      }));\n      function getAllByTag(_x26, _x27) {\n        return _getAllByTag.apply(this, arguments);\n      }\n      return getAllByTag;\n    }()\n    /**\n     * Queries documents from the Prismic repository with specific tags. A\n     * document must be tagged with all of the queried tags to be included.\n     *\n     * @example\n     *\n     * ```ts\n     * const response = await client.getByEveryTag([\"food\", \"fruit\"]);\n     * ```\n     *\n     * @typeParam TDocument - Type of Prismic documents returned.\n     *\n     * @param tags - A list of tags that must be included on a document.\n     * @param params - Parameters to filter, sort, and paginate the results.\n     *\n     * @returns A paginated response containing documents with the tags.\n     */\n  }, {\n    key: \"getByEveryTag\",\n    value: function () {\n      var _getByEveryTag = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee15(tags, params) {\n        return _regeneratorRuntime().wrap(function _callee15$(_context15) {\n          while (1) switch (_context15.prev = _context15.next) {\n            case 0:\n              _context15.next = 2;\n              return this.get(appendFilters(params, everyTagFilter(tags)));\n            case 2:\n              return _context15.abrupt(\"return\", _context15.sent);\n            case 3:\n            case \"end\":\n              return _context15.stop();\n          }\n        }, _callee15, this);\n      }));\n      function getByEveryTag(_x28, _x29) {\n        return _getByEveryTag.apply(this, arguments);\n      }\n      return getByEveryTag;\n    }()\n    /**\n     * Queries documents from the Prismic repository with specific tags. A\n     * document must be tagged with all of the queried tags to be included.\n     *\n     * This method may make multiple network requests to query all matching\n     * content.\n     *\n     * @example\n     *\n     * ```ts\n     * const response = await client.getAllByEveryTag([\"food\", \"fruit\"]);\n     * ```\n     *\n     * @typeParam TDocument - Type of Prismic documents returned.\n     *\n     * @param tags - A list of tags that must be included on a document.\n     * @param params - Parameters to filter, sort, and paginate the results.\n     *\n     * @returns A list of all documents with the tags.\n     */\n  }, {\n    key: \"getAllByEveryTag\",\n    value: function () {\n      var _getAllByEveryTag = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee16(tags, params) {\n        return _regeneratorRuntime().wrap(function _callee16$(_context16) {\n          while (1) switch (_context16.prev = _context16.next) {\n            case 0:\n              _context16.next = 2;\n              return this.dangerouslyGetAll(appendFilters(params, everyTagFilter(tags)));\n            case 2:\n              return _context16.abrupt(\"return\", _context16.sent);\n            case 3:\n            case \"end\":\n              return _context16.stop();\n          }\n        }, _callee16, this);\n      }));\n      function getAllByEveryTag(_x30, _x31) {\n        return _getAllByEveryTag.apply(this, arguments);\n      }\n      return getAllByEveryTag;\n    }()\n    /**\n     * Queries documents from the Prismic repository with specific tags. A\n     * document must be tagged with at least one of the queried tags to be\n     * included.\n     *\n     * @example\n     *\n     * ```ts\n     * const response = await client.getByEveryTag([\"food\", \"fruit\"]);\n     * ```\n     *\n     * @typeParam TDocument - Type of Prismic documents returned.\n     *\n     * @param tags - A list of tags that must be included on a document.\n     * @param params - Parameters to filter, sort, and paginate the results.\n     *\n     * @returns A paginated response containing documents with at least one of the\n     *   tags.\n     */\n  }, {\n    key: \"getBySomeTags\",\n    value: function () {\n      var _getBySomeTags = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee17(tags, params) {\n        return _regeneratorRuntime().wrap(function _callee17$(_context17) {\n          while (1) switch (_context17.prev = _context17.next) {\n            case 0:\n              _context17.next = 2;\n              return this.get(appendFilters(params, someTagsFilter(tags)));\n            case 2:\n              return _context17.abrupt(\"return\", _context17.sent);\n            case 3:\n            case \"end\":\n              return _context17.stop();\n          }\n        }, _callee17, this);\n      }));\n      function getBySomeTags(_x32, _x33) {\n        return _getBySomeTags.apply(this, arguments);\n      }\n      return getBySomeTags;\n    }()\n    /**\n     * Queries documents from the Prismic repository with specific tags. A\n     * document must be tagged with at least one of the queried tags to be\n     * included.\n     *\n     * This method may make multiple network requests to query all matching\n     * content.\n     *\n     * @example\n     *\n     * ```ts\n     * const response = await client.getAllBySomeTags([\"food\", \"fruit\"]);\n     * ```\n     *\n     * @typeParam TDocument - Type of Prismic documents returned.\n     *\n     * @param tags - A list of tags that must be included on a document.\n     * @param params - Parameters to filter, sort, and paginate the results.\n     *\n     * @returns A list of all documents with at least one of the tags.\n     */\n  }, {\n    key: \"getAllBySomeTags\",\n    value: function () {\n      var _getAllBySomeTags = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee18(tags, params) {\n        return _regeneratorRuntime().wrap(function _callee18$(_context18) {\n          while (1) switch (_context18.prev = _context18.next) {\n            case 0:\n              _context18.next = 2;\n              return this.dangerouslyGetAll(appendFilters(params, someTagsFilter(tags)));\n            case 2:\n              return _context18.abrupt(\"return\", _context18.sent);\n            case 3:\n            case \"end\":\n              return _context18.stop();\n          }\n        }, _callee18, this);\n      }));\n      function getAllBySomeTags(_x34, _x35) {\n        return _getAllBySomeTags.apply(this, arguments);\n      }\n      return getAllBySomeTags;\n    }()\n    /**\n     * Returns metadata about the Prismic repository, such as its refs, releases,\n     * and custom types.\n     *\n     * @returns Repository metadata.\n     */\n  }, {\n    key: \"getRepository\",\n    value: function () {\n      var _getRepository = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee19(params) {\n        var url;\n        return _regeneratorRuntime().wrap(function _callee19$(_context19) {\n          while (1) switch (_context19.prev = _context19.next) {\n            case 0:\n              url = new URL(this.endpoint);\n              if (this.accessToken) {\n                url.searchParams.set(\"access_token\", this.accessToken);\n              }\n              _context19.next = 4;\n              return this.fetch(url.toString(), params);\n            case 4:\n              return _context19.abrupt(\"return\", _context19.sent);\n            case 5:\n            case \"end\":\n              return _context19.stop();\n          }\n        }, _callee19, this);\n      }));\n      function getRepository(_x36) {\n        return _getRepository.apply(this, arguments);\n      }\n      return getRepository;\n    }()\n    /**\n     * Returns a list of all refs for the Prismic repository.\n     *\n     * Refs are used to identify which version of the repository's content should\n     * be queried. All repositories will have at least one ref pointing to the\n     * latest published content called the \"master ref\".\n     *\n     * @returns A list of all refs for the Prismic repository.\n     */\n  }, {\n    key: \"getRefs\",\n    value: function () {\n      var _getRefs = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee20(params) {\n        var repository;\n        return _regeneratorRuntime().wrap(function _callee20$(_context20) {\n          while (1) switch (_context20.prev = _context20.next) {\n            case 0:\n              _context20.next = 2;\n              return this.getRepository(params);\n            case 2:\n              repository = _context20.sent;\n              return _context20.abrupt(\"return\", repository.refs);\n            case 4:\n            case \"end\":\n              return _context20.stop();\n          }\n        }, _callee20, this);\n      }));\n      function getRefs(_x37) {\n        return _getRefs.apply(this, arguments);\n      }\n      return getRefs;\n    }()\n    /**\n     * Returns a ref for the Prismic repository with a matching ID.\n     *\n     * @param id - ID of the ref.\n     *\n     * @returns The ref with a matching ID, if it exists.\n     */\n  }, {\n    key: \"getRefByID\",\n    value: function () {\n      var _getRefByID = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee21(id, params) {\n        var refs;\n        return _regeneratorRuntime().wrap(function _callee21$(_context21) {\n          while (1) switch (_context21.prev = _context21.next) {\n            case 0:\n              _context21.next = 2;\n              return this.getRefs(params);\n            case 2:\n              refs = _context21.sent;\n              return _context21.abrupt(\"return\", findRefByID(refs, id));\n            case 4:\n            case \"end\":\n              return _context21.stop();\n          }\n        }, _callee21, this);\n      }));\n      function getRefByID(_x38, _x39) {\n        return _getRefByID.apply(this, arguments);\n      }\n      return getRefByID;\n    }()\n    /**\n     * Returns a ref for the Prismic repository with a matching label.\n     *\n     * @param label - Label of the ref.\n     *\n     * @returns The ref with a matching label, if it exists.\n     */\n  }, {\n    key: \"getRefByLabel\",\n    value: function () {\n      var _getRefByLabel = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee22(label, params) {\n        var refs;\n        return _regeneratorRuntime().wrap(function _callee22$(_context22) {\n          while (1) switch (_context22.prev = _context22.next) {\n            case 0:\n              _context22.next = 2;\n              return this.getRefs(params);\n            case 2:\n              refs = _context22.sent;\n              return _context22.abrupt(\"return\", findRefByLabel(refs, label));\n            case 4:\n            case \"end\":\n              return _context22.stop();\n          }\n        }, _callee22, this);\n      }));\n      function getRefByLabel(_x40, _x41) {\n        return _getRefByLabel.apply(this, arguments);\n      }\n      return getRefByLabel;\n    }()\n    /**\n     * Returns the master ref for the Prismic repository. The master ref points to\n     * the repository's latest published content.\n     *\n     * @returns The repository's master ref.\n     */\n  }, {\n    key: \"getMasterRef\",\n    value: function () {\n      var _getMasterRef = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee23(params) {\n        var refs;\n        return _regeneratorRuntime().wrap(function _callee23$(_context23) {\n          while (1) switch (_context23.prev = _context23.next) {\n            case 0:\n              _context23.next = 2;\n              return this.getRefs(params);\n            case 2:\n              refs = _context23.sent;\n              return _context23.abrupt(\"return\", findMasterRef(refs));\n            case 4:\n            case \"end\":\n              return _context23.stop();\n          }\n        }, _callee23, this);\n      }));\n      function getMasterRef(_x42) {\n        return _getMasterRef.apply(this, arguments);\n      }\n      return getMasterRef;\n    }()\n    /**\n     * Returns a list of all Releases for the Prismic repository. Releases are\n     * used to group content changes before publishing.\n     *\n     * @returns A list of all Releases for the Prismic repository.\n     */\n  }, {\n    key: \"getReleases\",\n    value: function () {\n      var _getReleases = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee24(params) {\n        var refs;\n        return _regeneratorRuntime().wrap(function _callee24$(_context24) {\n          while (1) switch (_context24.prev = _context24.next) {\n            case 0:\n              _context24.next = 2;\n              return this.getRefs(params);\n            case 2:\n              refs = _context24.sent;\n              return _context24.abrupt(\"return\", refs.filter(function (ref) {\n                return !ref.isMasterRef;\n              }));\n            case 4:\n            case \"end\":\n              return _context24.stop();\n          }\n        }, _callee24, this);\n      }));\n      function getReleases(_x43) {\n        return _getReleases.apply(this, arguments);\n      }\n      return getReleases;\n    }()\n    /**\n     * Returns a Release for the Prismic repository with a matching ID.\n     *\n     * @param id - ID of the Release.\n     *\n     * @returns The Release with a matching ID, if it exists.\n     */\n  }, {\n    key: \"getReleaseByID\",\n    value: function () {\n      var _getReleaseByID = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee25(id, params) {\n        var releases;\n        return _regeneratorRuntime().wrap(function _callee25$(_context25) {\n          while (1) switch (_context25.prev = _context25.next) {\n            case 0:\n              _context25.next = 2;\n              return this.getReleases(params);\n            case 2:\n              releases = _context25.sent;\n              return _context25.abrupt(\"return\", findRefByID(releases, id));\n            case 4:\n            case \"end\":\n              return _context25.stop();\n          }\n        }, _callee25, this);\n      }));\n      function getReleaseByID(_x44, _x45) {\n        return _getReleaseByID.apply(this, arguments);\n      }\n      return getReleaseByID;\n    }()\n    /**\n     * Returns a Release for the Prismic repository with a matching label.\n     *\n     * @param label - Label of the ref.\n     *\n     * @returns The ref with a matching label, if it exists.\n     */\n  }, {\n    key: \"getReleaseByLabel\",\n    value: function () {\n      var _getReleaseByLabel = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee26(label, params) {\n        var releases;\n        return _regeneratorRuntime().wrap(function _callee26$(_context26) {\n          while (1) switch (_context26.prev = _context26.next) {\n            case 0:\n              _context26.next = 2;\n              return this.getReleases(params);\n            case 2:\n              releases = _context26.sent;\n              return _context26.abrupt(\"return\", findRefByLabel(releases, label));\n            case 4:\n            case \"end\":\n              return _context26.stop();\n          }\n        }, _callee26, this);\n      }));\n      function getReleaseByLabel(_x46, _x47) {\n        return _getReleaseByLabel.apply(this, arguments);\n      }\n      return getReleaseByLabel;\n    }()\n    /**\n     * Returns a list of all tags used in the Prismic repository.\n     *\n     * @returns A list of all tags used in the repository.\n     */\n  }, {\n    key: \"getTags\",\n    value: function () {\n      var _getTags = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee27(params) {\n        var tagsForm, url, repository;\n        return _regeneratorRuntime().wrap(function _callee27$(_context27) {\n          while (1) switch (_context27.prev = _context27.next) {\n            case 0:\n              _context27.prev = 0;\n              _context27.next = 3;\n              return this.getCachedRepositoryForm(\"tags\", params);\n            case 3:\n              tagsForm = _context27.sent;\n              url = new URL(tagsForm.action);\n              if (this.accessToken) {\n                url.searchParams.set(\"access_token\", this.accessToken);\n              }\n              _context27.next = 8;\n              return this.fetch(url.toString(), params);\n            case 8:\n              return _context27.abrupt(\"return\", _context27.sent);\n            case 11:\n              _context27.prev = 11;\n              _context27.t0 = _context27[\"catch\"](0);\n              _context27.next = 15;\n              return this.getRepository(params);\n            case 15:\n              repository = _context27.sent;\n              return _context27.abrupt(\"return\", repository.tags);\n            case 17:\n            case \"end\":\n              return _context27.stop();\n          }\n        }, _callee27, this, [[0, 11]]);\n      }));\n      function getTags(_x48) {\n        return _getTags.apply(this, arguments);\n      }\n      return getTags;\n    }()\n    /**\n     * Builds a URL used to query content from the Prismic repository.\n     *\n     * @param params - Parameters to filter, sort, and paginate the results.\n     *\n     * @returns A URL string that can be requested to query content.\n     */\n  }, {\n    key: \"buildQueryURL\",\n    value: function () {\n      var _buildQueryURL2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee28() {\n        var _ref2,\n          signal,\n          fetchOptions,\n          params,\n          ref,\n          integrationFieldsRef,\n          _args28 = arguments;\n        return _regeneratorRuntime().wrap(function _callee28$(_context28) {\n          while (1) switch (_context28.prev = _context28.next) {\n            case 0:\n              _ref2 = _args28.length > 0 && _args28[0] !== undefined ? _args28[0] : {}, signal = _ref2.signal, fetchOptions = _ref2.fetchOptions, params = _objectWithoutProperties(_ref2, _excluded2);\n              _context28.t0 = params.ref;\n              if (_context28.t0) {\n                _context28.next = 6;\n                break;\n              }\n              _context28.next = 5;\n              return this.getResolvedRefString({\n                signal: signal,\n                fetchOptions: fetchOptions\n              });\n            case 5:\n              _context28.t0 = _context28.sent;\n            case 6:\n              ref = _context28.t0;\n              _context28.t2 = params.integrationFieldsRef;\n              if (_context28.t2) {\n                _context28.next = 12;\n                break;\n              }\n              _context28.next = 11;\n              return this.getCachedRepository({\n                signal: signal,\n                fetchOptions: fetchOptions\n              });\n            case 11:\n              _context28.t2 = _context28.sent.integrationFieldsRef;\n            case 12:\n              _context28.t1 = _context28.t2;\n              if (_context28.t1) {\n                _context28.next = 15;\n                break;\n              }\n              _context28.t1 = void 0;\n            case 15:\n              integrationFieldsRef = _context28.t1;\n              return _context28.abrupt(\"return\", _buildQueryURL(this.endpoint, _objectSpread(_objectSpread(_objectSpread({}, this.defaultParams), params), {}, {\n                ref: ref,\n                integrationFieldsRef: integrationFieldsRef,\n                routes: params.routes || this.routes,\n                brokenRoute: params.brokenRoute || this.brokenRoute,\n                accessToken: params.accessToken || this.accessToken\n              })));\n            case 17:\n            case \"end\":\n              return _context28.stop();\n          }\n        }, _callee28, this);\n      }));\n      function buildQueryURL() {\n        return _buildQueryURL2.apply(this, arguments);\n      }\n      return buildQueryURL;\n    }()\n    /**\n     * Determines the URL for a previewed document during an active preview\n     * session. The result of this method should be used to redirect the user to\n     * the document's URL.\n     *\n     * @example\n     *\n     * ```ts\n     * \tconst url = client.resolvePreviewURL({\n     * \tlinkResolver: (document) => `/${document.uid}`\n     * \tdefaultURL: '/'\n     * \t})\n     * ```\n     *\n     * @param args - Arguments to configure the URL resolving.\n     *\n     * @returns The URL for the previewed document during an active preview\n     *   session. The user should be redirected to this URL.\n     */\n  }, {\n    key: \"resolvePreviewURL\",\n    value: function () {\n      var _resolvePreviewURL = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee29(args) {\n        var _a, _b, documentID, previewToken, searchParams, _searchParams, document, url;\n        return _regeneratorRuntime().wrap(function _callee29$(_context29) {\n          while (1) switch (_context29.prev = _context29.next) {\n            case 0:\n              documentID = args.documentID;\n              previewToken = args.previewToken;\n              if (typeof globalThis.location !== \"undefined\") {\n                searchParams = new URLSearchParams(globalThis.location.search);\n                documentID = documentID || searchParams.get(\"documentId\");\n                previewToken = previewToken || searchParams.get(\"token\");\n              } else if (this.refState.httpRequest) {\n                if (\"query\" in this.refState.httpRequest) {\n                  documentID = documentID || ((_a = this.refState.httpRequest.query) == null ? void 0 : _a.documentId);\n                  previewToken = previewToken || ((_b = this.refState.httpRequest.query) == null ? void 0 : _b.token);\n                } else if (\"url\" in this.refState.httpRequest && this.refState.httpRequest.url) {\n                  _searchParams = new URL(this.refState.httpRequest.url, \"missing-host://\").searchParams;\n                  documentID = documentID || _searchParams.get(\"documentId\");\n                  previewToken = previewToken || _searchParams.get(\"token\");\n                }\n              }\n              if (!(documentID != null && previewToken != null)) {\n                _context29.next = 10;\n                break;\n              }\n              _context29.next = 6;\n              return this.getByID(documentID, {\n                ref: previewToken,\n                lang: \"*\",\n                signal: args.signal,\n                fetchOptions: args.fetchOptions\n              });\n            case 6:\n              document = _context29.sent;\n              url = asLink(document, {\n                linkResolver: args.linkResolver\n              });\n              if (!(typeof url === \"string\")) {\n                _context29.next = 10;\n                break;\n              }\n              return _context29.abrupt(\"return\", url);\n            case 10:\n              return _context29.abrupt(\"return\", args.defaultURL);\n            case 11:\n            case \"end\":\n              return _context29.stop();\n          }\n        }, _callee29, this);\n      }));\n      function resolvePreviewURL(_x49) {\n        return _resolvePreviewURL.apply(this, arguments);\n      }\n      return resolvePreviewURL;\n    }()\n    /**\n     * Configures the client to query the latest published content for all future\n     * queries.\n     *\n     * If the `ref` parameter is provided during a query, it takes priority for\n     * that query.\n     *\n     * @example\n     *\n     * ```ts\n     * await client.queryLatestContent();\n     * const document = await client.getByID(\"WW4bKScAAMAqmluX\");\n     * ```\n     */\n  }, {\n    key: \"queryLatestContent\",\n    value: function queryLatestContent() {\n      this.refState.mode = RefStateMode.Master;\n    }\n    /**\n     * Configures the client to query content from a specific Release identified\n     * by its ID for all future queries.\n     *\n     * If the `ref` parameter is provided during a query, it takes priority for\n     * that query.\n     *\n     * @example\n     *\n     * ```ts\n     * await client.queryContentFromReleaseByID(\"YLB7OBAAACMA7Cpa\");\n     * const document = await client.getByID(\"WW4bKScAAMAqmluX\");\n     * ```\n     *\n     * @param releaseID - The ID of the Release.\n     */\n  }, {\n    key: \"queryContentFromReleaseByID\",\n    value: function queryContentFromReleaseByID(releaseID) {\n      this.refState = _objectSpread(_objectSpread({}, this.refState), {}, {\n        mode: RefStateMode.ReleaseID,\n        releaseID: releaseID\n      });\n    }\n    /**\n     * Configures the client to query content from a specific Release identified\n     * by its label for all future queries.\n     *\n     * If the `ref` parameter is provided during a query, it takes priority for\n     * that query.\n     *\n     * @example\n     *\n     * ```ts\n     * await client.queryContentFromReleaseByLabel(\"My Release\");\n     * const document = await client.getByID(\"WW4bKScAAMAqmluX\");\n     * ```\n     *\n     * @param releaseLabel - The label of the Release.\n     */\n  }, {\n    key: \"queryContentFromReleaseByLabel\",\n    value: function queryContentFromReleaseByLabel(releaseLabel) {\n      this.refState = _objectSpread(_objectSpread({}, this.refState), {}, {\n        mode: RefStateMode.ReleaseLabel,\n        releaseLabel: releaseLabel\n      });\n    }\n    /**\n     * Configures the client to query content from a specific ref. The ref can be\n     * provided as a string or a function.\n     *\n     * If a function is provided, the ref is fetched lazily before each query. The\n     * function may also be asynchronous.\n     *\n     * @example\n     *\n     * ```ts\n     * await client.queryContentFromRef(\"my-ref\");\n     * const document = await client.getByID(\"WW4bKScAAMAqmluX\");\n     * ```\n     *\n     * @param ref - The ref or a function that returns the ref from which to query\n     *   content.\n     */\n  }, {\n    key: \"queryContentFromRef\",\n    value: function queryContentFromRef(ref) {\n      this.refState = _objectSpread(_objectSpread({}, this.refState), {}, {\n        mode: RefStateMode.Manual,\n        ref: ref\n      });\n    }\n    /**\n     * A `fetch()` function to be used with GraphQL clients configured for\n     * Prismic's GraphQL API. It automatically applies the necessary `prismic-ref`\n     * and Authorization headers. Queries will automatically be minified by\n     * removing whitespace where possible.\n     *\n     * @example\n     *\n     * ```ts\n     * const graphQLClient = new ApolloClient({\n     * \tlink: new HttpLink({\n     * \t\turi: prismic.getGraphQLEndpoint(repositoryName),\n     * \t\t// Provide `client.graphQLFetch` as the fetch implementation.\n     * \t\tfetch: client.graphQLFetch,\n     * \t\t// Using GET is required.\n     * \t\tuseGETForQueries: true,\n     * \t}),\n     * \tcache: new InMemoryCache(),\n     * });\n     * ```\n     *\n     * @param input - The `fetch()` `input` parameter. Only strings are supported.\n     * @param init - The `fetch()` `init` parameter. Only plain objects are\n     *   supported.\n     *\n     * @returns The `fetch()` Response for the request.\n     *\n     * @experimental\n     */\n  }, {\n    key: \"graphQLFetch\",\n    value: function () {\n      var _graphQLFetch = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee30(input, init) {\n        var cachedRepository, ref, unsanitizedHeaders, headers, key, url, query;\n        return _regeneratorRuntime().wrap(function _callee30$(_context30) {\n          while (1) switch (_context30.prev = _context30.next) {\n            case 0:\n              _context30.next = 2;\n              return this.getCachedRepository();\n            case 2:\n              cachedRepository = _context30.sent;\n              _context30.next = 5;\n              return this.getResolvedRefString();\n            case 5:\n              ref = _context30.sent;\n              unsanitizedHeaders = _objectSpread({\n                \"Prismic-ref\": ref,\n                Authorization: this.accessToken ? \"Token \".concat(this.accessToken) : \"\"\n              }, init ? init.headers : {});\n              if (cachedRepository.integrationFieldsRef) {\n                unsanitizedHeaders[\"Prismic-integration-field-ref\"] = cachedRepository.integrationFieldsRef;\n              }\n              headers = {};\n              for (key in unsanitizedHeaders) {\n                if (unsanitizedHeaders[key]) {\n                  headers[key.toLowerCase()] = unsanitizedHeaders[key];\n                }\n              }\n              url = new URL(\n              // Asserting `input` is a string since popular GraphQL\n              // libraries pass this as a string. Request objects as\n              // input are unsupported.\n              input);\n              url.searchParams.set(\"ref\", ref);\n              query = url.searchParams.get(\"query\");\n              if (query) {\n                url.searchParams.set(\"query\",\n                // Compress the GraphQL query (if it exists) by\n                // removing whitespace. This is done to\n                // optimize the query size and avoid\n                // hitting the upper limit of GET requests\n                // (2048 characters).\n                minifyGraphQLQuery(query));\n              }\n              _context30.next = 16;\n              return this.fetchFn(url.toString(), _objectSpread(_objectSpread({}, init), {}, {\n                headers: headers\n              }));\n            case 16:\n              return _context30.abrupt(\"return\", _context30.sent);\n            case 17:\n            case \"end\":\n              return _context30.stop();\n          }\n        }, _callee30, this);\n      }));\n      function graphQLFetch(_x50, _x51) {\n        return _graphQLFetch.apply(this, arguments);\n      }\n      return graphQLFetch;\n    }()\n    /**\n     * Returns a cached version of `getRepository` with a TTL.\n     *\n     * @returns Cached repository metadata.\n     */\n  }, {\n    key: \"getCachedRepository\",\n    value: function () {\n      var _getCachedRepository = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee31(params) {\n        return _regeneratorRuntime().wrap(function _callee31$(_context31) {\n          while (1) switch (_context31.prev = _context31.next) {\n            case 0:\n              if (!(!this.cachedRepository || Date.now() >= this.cachedRepositoryExpiration)) {\n                _context31.next = 5;\n                break;\n              }\n              this.cachedRepositoryExpiration = Date.now() + REPOSITORY_CACHE_TTL;\n              _context31.next = 4;\n              return this.getRepository(params);\n            case 4:\n              this.cachedRepository = _context31.sent;\n            case 5:\n              return _context31.abrupt(\"return\", this.cachedRepository);\n            case 6:\n            case \"end\":\n              return _context31.stop();\n          }\n        }, _callee31, this);\n      }));\n      function getCachedRepository(_x52) {\n        return _getCachedRepository.apply(this, arguments);\n      }\n      return getCachedRepository;\n    }()\n    /**\n     * Returns a cached Prismic repository form. Forms are used to determine API\n     * endpoints for types of repository data.\n     *\n     * @param name - Name of the form.\n     *\n     * @returns The repository form.\n     *\n     * @throws If a matching form cannot be found.\n     */\n  }, {\n    key: \"getCachedRepositoryForm\",\n    value: function () {\n      var _getCachedRepositoryForm = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee32(name, params) {\n        var cachedRepository, form;\n        return _regeneratorRuntime().wrap(function _callee32$(_context32) {\n          while (1) switch (_context32.prev = _context32.next) {\n            case 0:\n              _context32.next = 2;\n              return this.getCachedRepository(params);\n            case 2:\n              cachedRepository = _context32.sent;\n              form = cachedRepository.forms[name];\n              if (form) {\n                _context32.next = 6;\n                break;\n              }\n              throw new PrismicError(\"Form with name \\\"\".concat(name, \"\\\" could not be found\"), void 0, void 0);\n            case 6:\n              return _context32.abrupt(\"return\", form);\n            case 7:\n            case \"end\":\n              return _context32.stop();\n          }\n        }, _callee32, this);\n      }));\n      function getCachedRepositoryForm(_x53, _x54) {\n        return _getCachedRepositoryForm.apply(this, arguments);\n      }\n      return getCachedRepositoryForm;\n    }()\n    /**\n     * Returns the ref needed to query based on the client's current state. This\n     * method may make a network request to fetch a ref or resolve the user's ref\n     * thunk.\n     *\n     * If auto previews are enabled, the preview ref takes priority if available.\n     *\n     * The following strategies are used depending on the client's state:\n     *\n     * - If the user called `queryLatestContent`: Use the repository's master ref.\n     *   The ref is cached for 5 seconds. After 5 seconds, a new master ref is\n     *   fetched.\n     * - If the user called `queryContentFromReleaseByID`: Use the release's ref.\n     *   The ref is cached for 5 seconds. After 5 seconds, a new ref for the\n     *   release is fetched.\n     * - If the user called `queryContentFromReleaseByLabel`: Use the release's ref.\n     *   The ref is cached for 5 seconds. After 5 seconds, a new ref for the\n     *   release is fetched.\n     * - If the user called `queryContentFromRef`: Use the provided ref. Fall back\n     *   to the master ref if the ref is not a string.\n     *\n     * @returns The ref to use during a query.\n     */\n  }, {\n    key: \"getResolvedRefString\",\n    value: function () {\n      var _getResolvedRefString = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee33(params) {\n        var _a, _b, previewRef, cookieJar, cachedRepository, refModeType, res;\n        return _regeneratorRuntime().wrap(function _callee33$(_context33) {\n          while (1) switch (_context33.prev = _context33.next) {\n            case 0:\n              if (!this.refState.autoPreviewsEnabled) {\n                _context33.next = 5;\n                break;\n              }\n              if ((_a = this.refState.httpRequest) == null ? void 0 : _a.headers) {\n                if (\"get\" in this.refState.httpRequest.headers && typeof this.refState.httpRequest.headers.get === \"function\") {\n                  cookieJar = this.refState.httpRequest.headers.get(\"cookie\");\n                } else if (\"cookie\" in this.refState.httpRequest.headers) {\n                  cookieJar = this.refState.httpRequest.headers.cookie;\n                }\n              } else if ((_b = globalThis.document) == null ? void 0 : _b.cookie) {\n                cookieJar = globalThis.document.cookie;\n              }\n              if (cookieJar) {\n                previewRef = getPreviewCookie(cookieJar);\n              }\n              if (!previewRef) {\n                _context33.next = 5;\n                break;\n              }\n              return _context33.abrupt(\"return\", previewRef);\n            case 5:\n              _context33.next = 7;\n              return this.getCachedRepository(params);\n            case 7:\n              cachedRepository = _context33.sent;\n              refModeType = this.refState.mode;\n              if (!(refModeType === RefStateMode.ReleaseID)) {\n                _context33.next = 13;\n                break;\n              }\n              return _context33.abrupt(\"return\", findRefByID(cachedRepository.refs, this.refState.releaseID).ref);\n            case 13:\n              if (!(refModeType === RefStateMode.ReleaseLabel)) {\n                _context33.next = 17;\n                break;\n              }\n              return _context33.abrupt(\"return\", findRefByLabel(cachedRepository.refs, this.refState.releaseLabel).ref);\n            case 17:\n              if (!(refModeType === RefStateMode.Manual)) {\n                _context33.next = 23;\n                break;\n              }\n              _context33.next = 20;\n              return castThunk(this.refState.ref)();\n            case 20:\n              res = _context33.sent;\n              if (!(typeof res === \"string\")) {\n                _context33.next = 23;\n                break;\n              }\n              return _context33.abrupt(\"return\", res);\n            case 23:\n              return _context33.abrupt(\"return\", findMasterRef(cachedRepository.refs).ref);\n            case 24:\n            case \"end\":\n              return _context33.stop();\n          }\n        }, _callee33, this);\n      }));\n      function getResolvedRefString(_x55) {\n        return _getResolvedRefString.apply(this, arguments);\n      }\n      return getResolvedRefString;\n    }()\n    /**\n     * Performs a network request using the configured `fetch` function. It\n     * assumes all successful responses will have a JSON content type. It also\n     * normalizes unsuccessful network requests.\n     *\n     * @typeParam T - The JSON response.\n     *\n     * @param url - URL to the resource to fetch.\n     * @param params - Prismic REST API parameters for the network request.\n     *\n     * @returns The JSON response from the network request.\n     */\n  }, {\n    key: \"fetch\",\n    value: function () {\n      var _fetch = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee35(url) {\n        var _this = this;\n        var params,\n          _a,\n          _b,\n          _c,\n          _d,\n          requestInit,\n          job,\n          res,\n          _args35 = arguments;\n        return _regeneratorRuntime().wrap(function _callee35$(_context35) {\n          while (1) switch (_context35.prev = _context35.next) {\n            case 0:\n              params = _args35.length > 1 && _args35[1] !== undefined ? _args35[1] : {};\n              requestInit = _objectSpread(_objectSpread(_objectSpread({}, this.fetchOptions), params.fetchOptions), {}, {\n                headers: _objectSpread(_objectSpread({}, (_a = this.fetchOptions) == null ? void 0 : _a.headers), (_b = params.fetchOptions) == null ? void 0 : _b.headers),\n                signal: ((_c = params.fetchOptions) == null ? void 0 : _c.signal) || params.signal || ((_d = this.fetchOptions) == null ? void 0 : _d.signal)\n              });\n              if (this.fetchJobs[url] && this.fetchJobs[url].has(requestInit.signal)) {\n                job = this.fetchJobs[url].get(requestInit.signal);\n              } else {\n                this.fetchJobs[url] = this.fetchJobs[url] || /* @__PURE__ */new Map();\n                job = this.fetchFn(url, requestInit).then( /*#__PURE__*/function () {\n                  var _ref3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee34(res2) {\n                    var json;\n                    return _regeneratorRuntime().wrap(function _callee34$(_context34) {\n                      while (1) switch (_context34.prev = _context34.next) {\n                        case 0:\n                          json = void 0;\n                          _context34.prev = 1;\n                          _context34.next = 4;\n                          return res2.json();\n                        case 4:\n                          json = _context34.sent;\n                          _context34.next = 9;\n                          break;\n                        case 7:\n                          _context34.prev = 7;\n                          _context34.t0 = _context34[\"catch\"](1);\n                        case 9:\n                          return _context34.abrupt(\"return\", {\n                            status: res2.status,\n                            json: json\n                          });\n                        case 10:\n                        case \"end\":\n                          return _context34.stop();\n                      }\n                    }, _callee34, null, [[1, 7]]);\n                  }));\n                  return function (_x57) {\n                    return _ref3.apply(this, arguments);\n                  };\n                }()).finally(function () {\n                  _this.fetchJobs[url].delete(requestInit.signal);\n                  if (_this.fetchJobs[url].size === 0) {\n                    delete _this.fetchJobs[url];\n                  }\n                });\n                this.fetchJobs[url].set(requestInit.signal, job);\n              }\n              _context35.next = 5;\n              return job;\n            case 5:\n              res = _context35.sent;\n              if (!(res.status !== 404 && res.json == null)) {\n                _context35.next = 8;\n                break;\n              }\n              throw new PrismicError(void 0, url, res.json);\n            case 8:\n              _context35.t0 = res.status;\n              _context35.next = _context35.t0 === 200 ? 11 : _context35.t0 === 400 ? 12 : _context35.t0 === 401 ? 13 : _context35.t0 === 403 ? 13 : _context35.t0 === 404 ? 14 : 15;\n              break;\n            case 11:\n              return _context35.abrupt(\"return\", res.json);\n            case 12:\n              throw new ParsingError(res.json.message, url, res.json);\n            case 13:\n              throw new ForbiddenError(\"error\" in res.json ? res.json.error : res.json.message, url, res.json);\n            case 14:\n              throw new NotFoundError(\"Prismic repository not found. Check that \\\"\".concat(this.endpoint, \"\\\" is pointing to the correct repository.\"), url, void 0);\n            case 15:\n              throw new PrismicError(void 0, url, res.json);\n            case 16:\n            case \"end\":\n              return _context35.stop();\n          }\n        }, _callee35, this);\n      }));\n      function fetch(_x56) {\n        return _fetch.apply(this, arguments);\n      }\n      return fetch;\n    }()\n  }]);\n  return Client;\n}();\nexport { Client, GET_ALL_QUERY_DELAY, REPOSITORY_CACHE_TTL, createClient };","map":{"version":3,"names":["MAX_PAGE_SIZE","REPOSITORY_CACHE_TTL","GET_ALL_QUERY_DELAY","RefStateMode","RefStateMode2","createClient","repositoryNameOrEndpoint","options","Client","arguments","length","undefined","_classCallCheck","__publicField","mode","Master","autoPreviewsEnabled","isRepositoryEndpoint","process","env","NODE_ENV","test","PrismicError","hostname","URL","toLowerCase","endsWith","repositoryName","getRepositoryName","dotCDNEndpoint","getRepositoryEndpoint","console","warn","concat","devMsg","endpoint","accessToken","routes","brokenRoute","fetchOptions","defaultParams","ref","queryContentFromRef","fetch","fetchFn","globalThis","bind","graphQLFetch","_createClass","key","value","enableAutoPreviews","refState","enableAutoPreviewsFromReq","req","httpRequest","disableAutoPreviews","_get","_asyncToGenerator","_regeneratorRuntime","mark","_callee","params","url","wrap","_callee$","_context","prev","next","buildQueryURL","sent","abrupt","stop","get","_x","apply","_getFirst","_callee2","_a","actualParams","_ref","result","firstResult","_callee2$","_context2","_objectSpread","page","pageSize","results","getFirst","_x2","_dangerouslyGetAll","_callee3","_params$limit","limit","resolvedParams","documents","latestResult","_args3","_callee3$","_context3","Infinity","_objectWithoutProperties","_excluded","Math","min","next_page","push","_toConsumableArray","Promise","res","setTimeout","slice","dangerouslyGetAll","_getByID","_callee4","id","_callee4$","_context4","appendFilters","filter","at","getByID","_x3","_x4","_getByIDs","_callee5","ids","_callee5$","_context5","in","getByIDs","_x5","_x6","_getAllByIDs","_callee6","_callee6$","_context6","getAllByIDs","_x7","_x8","_getByUID","_callee7","documentType","uid","_callee7$","_context7","typeFilter","getByUID","_x9","_x10","_x11","_getByUIDs","_callee8","uids","_callee8$","_context8","getByUIDs","_x12","_x13","_x14","_getAllByUIDs","_callee9","_callee9$","_context9","getAllByUIDs","_x15","_x16","_x17","_getSingle","_callee10","_callee10$","_context10","getSingle","_x18","_x19","_getByType","_callee11","_callee11$","_context11","getByType","_x20","_x21","_getAllByType","_callee12","_callee12$","_context12","getAllByType","_x22","_x23","_getByTag","_callee13","tag","_callee13$","_context13","someTagsFilter","getByTag","_x24","_x25","_getAllByTag","_callee14","_callee14$","_context14","getAllByTag","_x26","_x27","_getByEveryTag","_callee15","tags","_callee15$","_context15","everyTagFilter","getByEveryTag","_x28","_x29","_getAllByEveryTag","_callee16","_callee16$","_context16","getAllByEveryTag","_x30","_x31","_getBySomeTags","_callee17","_callee17$","_context17","getBySomeTags","_x32","_x33","_getAllBySomeTags","_callee18","_callee18$","_context18","getAllBySomeTags","_x34","_x35","_getRepository","_callee19","_callee19$","_context19","searchParams","set","toString","getRepository","_x36","_getRefs","_callee20","repository","_callee20$","_context20","refs","getRefs","_x37","_getRefByID","_callee21","_callee21$","_context21","findRefByID","getRefByID","_x38","_x39","_getRefByLabel","_callee22","label","_callee22$","_context22","findRefByLabel","getRefByLabel","_x40","_x41","_getMasterRef","_callee23","_callee23$","_context23","findMasterRef","getMasterRef","_x42","_getReleases","_callee24","_callee24$","_context24","isMasterRef","getReleases","_x43","_getReleaseByID","_callee25","releases","_callee25$","_context25","getReleaseByID","_x44","_x45","_getReleaseByLabel","_callee26","_callee26$","_context26","getReleaseByLabel","_x46","_x47","_getTags","_callee27","tagsForm","_callee27$","_context27","getCachedRepositoryForm","action","t0","getTags","_x48","_buildQueryURL2","_callee28","_ref2","signal","integrationFieldsRef","_args28","_callee28$","_context28","_excluded2","getResolvedRefString","t2","getCachedRepository","t1","_resolvePreviewURL","_callee29","args","_b","documentID","previewToken","_searchParams","document","_callee29$","_context29","location","URLSearchParams","search","query","documentId","token","lang","asLink","linkResolver","defaultURL","resolvePreviewURL","_x49","queryLatestContent","queryContentFromReleaseByID","releaseID","ReleaseID","queryContentFromReleaseByLabel","releaseLabel","ReleaseLabel","Manual","_graphQLFetch","_callee30","input","init","cachedRepository","unsanitizedHeaders","headers","_callee30$","_context30","Authorization","minifyGraphQLQuery","_x50","_x51","_getCachedRepository","_callee31","_callee31$","_context31","Date","now","cachedRepositoryExpiration","_x52","_getCachedRepositoryForm","_callee32","name","form","_callee32$","_context32","forms","_x53","_x54","_getResolvedRefString","_callee33","previewRef","cookieJar","refModeType","_callee33$","_context33","cookie","getPreviewCookie","castThunk","_x55","_fetch","_callee35","_this","_c","_d","requestInit","job","_args35","_callee35$","_context35","fetchJobs","has","Map","then","_ref3","_callee34","res2","json","_callee34$","_context34","status","_x57","finally","delete","size","ParsingError","message","ForbiddenError","error","NotFoundError","_x56"],"sources":["E:\\Aarhat Iserv - E-commerce\\new\\ariz\\Frontend\\node_modules\\@prismicio\\src\\createClient.ts"],"sourcesContent":["import { appendFilters } from \"./lib/appendFilters\";\nimport { castThunk } from \"./lib/castThunk\";\nimport { devMsg } from \"./lib/devMsg\";\nimport { everyTagFilter } from \"./lib/everyTagFilter\";\nimport { findMasterRef } from \"./lib/findMasterRef\";\nimport { findRefByID } from \"./lib/findRefByID\";\nimport { findRefByLabel } from \"./lib/findRefByLabel\";\nimport { getPreviewCookie } from \"./lib/getPreviewCookie\";\nimport { minifyGraphQLQuery } from \"./lib/minifyGraphQLQuery\";\nimport { someTagsFilter } from \"./lib/someTagsFilter\";\nimport { typeFilter } from \"./lib/typeFilter\";\n\nimport type { Query } from \"./types/api/query\";\nimport type { Ref } from \"./types/api/ref\";\nimport type { Form, Repository } from \"./types/api/repository\";\nimport type { PrismicDocument } from \"./types/value/document\";\n\nimport { ForbiddenError } from \"./errors/ForbiddenError\";\nimport { NotFoundError } from \"./errors/NotFoundError\";\nimport { ParsingError } from \"./errors/ParsingError\";\nimport { PrismicError } from \"./errors/PrismicError\";\n\nimport { LinkResolverFunction, asLink } from \"./helpers/asLink\";\n\nimport { BuildQueryURLArgs, buildQueryURL } from \"./buildQueryURL\";\nimport { filter } from \"./filter\";\nimport { getRepositoryEndpoint } from \"./getRepositoryEndpoint\";\nimport { getRepositoryName } from \"./getRepositoryName\";\nimport { isRepositoryEndpoint } from \"./isRepositoryEndpoint\";\n\n/**\n * The largest page size allowed by the Prismic REST API V2. This value is used\n * to minimize the number of requests required to query content.\n */\nconst MAX_PAGE_SIZE = 100;\n\n/**\n * The number of milliseconds in which repository metadata is considered valid.\n * A ref can be invalidated quickly depending on how frequently content is\n * updated in the Prismic repository. As such, repository's metadata can only be\n * considered valid for a short amount of time.\n */\nexport const REPOSITORY_CACHE_TTL = 5000;\n\n/**\n * The number of milliseconds in which a multi-page `getAll` (e.g. `getAll`,\n * `getAllByType`, `getAllByTag`) will wait between individual page requests.\n *\n * This is done to ensure API performance is sustainable and reduces the chance\n * of a failed API request due to overloading.\n */\nexport const GET_ALL_QUERY_DELAY = 500;\n\n/**\n * Extracts one or more Prismic document types that match a given Prismic\n * document type. If no matches are found, no extraction is performed and the\n * union of all provided Prismic document types are returned.\n *\n * @typeParam TDocuments - Prismic document types from which to extract.\n * @typeParam TDocumentType - Type(s) to match `TDocuments` against.\n */\ntype ExtractDocumentType<\n\tTDocuments extends PrismicDocument,\n\tTDocumentType extends TDocuments[\"type\"],\n> = Extract<TDocuments, { type: TDocumentType }> extends never\n\t? TDocuments\n\t: Extract<TDocuments, { type: TDocumentType }>;\n\n/**\n * A universal API to make network requests. A subset of the `fetch()` API.\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/API/fetch}\n */\nexport type FetchLike = (\n\tinput: string,\n\tinit?: RequestInitLike,\n) => Promise<ResponseLike>;\n\n/**\n * An object that allows you to abort a `fetch()` request if needed via an\n * `AbortController` object\n *\n * {@link https://developer.mozilla.org/en-US/docs/Web/API/AbortSignal}\n */\n// `any` is used often here to ensure this type is universally valid among\n// different AbortSignal implementations. The types of each property are not\n// important to validate since it is blindly passed to a given `fetch()`\n// function.\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport type AbortSignalLike = any;\n\n/**\n * A subset of RequestInit properties to configure a `fetch()` request.\n */\n// Only options relevant to the client are included. Extending from the full\n// RequestInit would cause issues, such as accepting Header objects.\n//\n// An interface is used to allow other libraries to augment the type with\n// environment-specific types.\nexport interface RequestInitLike extends Pick<RequestInit, \"cache\"> {\n\t/**\n\t * An object literal to set the `fetch()` request's headers.\n\t */\n\theaders?: Record<string, string>;\n\n\t/**\n\t * An AbortSignal to set the `fetch()` request's signal.\n\t *\n\t * See:\n\t * [https://developer.mozilla.org/en-US/docs/Web/API/AbortSignal](https://developer.mozilla.org/en-US/docs/Web/API/AbortSignal)\n\t */\n\t// NOTE: `AbortSignalLike` is `any`! It is left as `AbortSignalLike`\n\t// for backwards compatibility (the type is exported) and to signal to\n\t// other readers that this should be an AbortSignal-like object.\n\tsignal?: AbortSignalLike;\n}\n\n/**\n * The minimum required properties from Response.\n */\nexport interface ResponseLike {\n\tstatus: number;\n\t// eslint-disable-next-line @typescript-eslint/no-explicit-any\n\tjson(): Promise<any>;\n}\n\n/**\n * The minimum required properties to treat as an HTTP Request for automatic\n * Prismic preview support.\n */\nexport type HttpRequestLike =\n\t| /**\n\t * Web API Request\n\t *\n\t * @see http://developer.mozilla.org/en-US/docs/Web/API/Request\n\t */\n\t{\n\t\t\theaders?: {\n\t\t\t\tget(name: string): string | null;\n\t\t\t};\n\t\t\turl?: string;\n\t  }\n\n\t/**\n\t * Express-style Request\n\t */\n\t| {\n\t\t\theaders?: {\n\t\t\t\tcookie?: string;\n\t\t\t};\n\t\t\tquery?: Record<string, unknown>;\n\t  };\n\n/**\n * Modes for client ref management.\n */\nenum RefStateMode {\n\t/**\n\t * Use the repository's master ref.\n\t */\n\tMaster = \"Master\",\n\n\t/**\n\t * Use a given Release identified by its ID.\n\t */\n\tReleaseID = \"ReleaseID\",\n\n\t/**\n\t * Use a given Release identified by its label.\n\t */\n\tReleaseLabel = \"ReleaseLabel\",\n\n\t/**\n\t * Use a given ref.\n\t */\n\tManual = \"Manual\",\n}\n\n/**\n * An object containing stateful information about a client's ref strategy.\n */\ntype RefState = {\n\t/**\n\t * Determines if automatic preview support is enabled.\n\t */\n\tautoPreviewsEnabled: boolean;\n\n\t/**\n\t * An optional HTTP server request object used during previews if automatic\n\t * previews are enabled.\n\t */\n\thttpRequest?: HttpRequestLike;\n} & (\n\t| {\n\t\t\tmode: RefStateMode.Master;\n\t  }\n\t| {\n\t\t\tmode: RefStateMode.ReleaseID;\n\t\t\treleaseID: string;\n\t  }\n\t| {\n\t\t\tmode: RefStateMode.ReleaseLabel;\n\t\t\treleaseLabel: string;\n\t  }\n\t| {\n\t\t\tmode: RefStateMode.Manual;\n\t\t\tref: RefStringOrThunk;\n\t  }\n);\n\n/**\n * A ref or a function that returns a ref. If a static ref is known, one can be\n * given. If the ref must be fetched on-demand, a function can be provided. This\n * function can optionally be asynchronous.\n */\ntype RefStringOrThunk =\n\t| string\n\t| (() => string | undefined | Promise<string | undefined>);\n\n/**\n * Configuration for clients that determine how content is queried.\n */\nexport type ClientConfig = {\n\t/**\n\t * The secure token for accessing the Prismic repository. This is only\n\t * required if the repository is set to private.\n\t */\n\taccessToken?: string;\n\n\t/**\n\t * A string representing a version of the Prismic repository's content. This\n\t * may point to the latest version (called the \"master ref\"), or a preview\n\t * with draft content.\n\t */\n\tref?: RefStringOrThunk;\n\n\t/**\n\t * A list of route resolver objects that define how a document's `url`\n\t * property is resolved.\n\t *\n\t * {@link https://prismic.io/docs/route-resolver}\n\t */\n\troutes?: NonNullable<BuildQueryURLArgs[\"routes\"]>;\n\n\t/**\n\t * The `brokenRoute` option allows you to define the route populated in the\n\t * `url` property for broken link or content relationship fields. A broken\n\t * link is a link or content relationship field whose linked document has been\n\t * unpublished or deleted.\n\t *\n\t * {@link https://prismic.io/docs/route-resolver}\n\t */\n\tbrokenRoute?: NonNullable<BuildQueryURLArgs[\"brokenRoute\"]>;\n\n\t/**\n\t * Default parameters that will be sent with each query. These parameters can\n\t * be overridden on each query if needed.\n\t */\n\tdefaultParams?: Omit<\n\t\tBuildQueryURLArgs,\n\t\t\"ref\" | \"integrationFieldsRef\" | \"accessToken\" | \"routes\" | \"brokenRoute\"\n\t>;\n\n\t/**\n\t * The function used to make network requests to the Prismic REST API. In\n\t * environments where a global `fetch` function does not exist, such as\n\t * Node.js, this function must be provided.\n\t */\n\tfetch?: FetchLike;\n\n\t/**\n\t * Options provided to the client's `fetch()` on all network requests. These\n\t * options will be merged with internally required options. They can also be\n\t * overriden on a per-query basis using the query's `fetchOptions` parameter.\n\t */\n\tfetchOptions?: RequestInitLike;\n};\n\n/**\n * Parameters for any client method that use `fetch()`.\n */\ntype FetchParams = {\n\t/**\n\t * Options provided to the client's `fetch()` on all network requests. These\n\t * options will be merged with internally required options. They can also be\n\t * overriden on a per-query basis using the query's `fetchOptions` parameter.\n\t */\n\tfetchOptions?: RequestInitLike;\n\n\t/**\n\t * An `AbortSignal` provided by an `AbortController`. This allows the network\n\t * request to be cancelled if necessary.\n\t *\n\t * @deprecated Move the `signal` parameter into `fetchOptions.signal`:\n\t *\n\t * @see \\<https://developer.mozilla.org/en-US/docs/Web/API/AbortSignal\\>\n\t */\n\tsignal?: AbortSignalLike;\n};\n\n/**\n * Parameters specific to client methods that fetch all documents. These methods\n * start with `getAll` (for example, `getAllByType`).\n */\ntype GetAllParams = {\n\t/**\n\t * Limit the number of documents queried. If a number is not provided, there\n\t * will be no limit and all matching documents will be returned.\n\t */\n\tlimit?: number;\n};\n\n/**\n * Arguments to determine how the URL for a preview session is resolved.\n */\ntype ResolvePreviewArgs<LinkResolverReturnType> = {\n\t/**\n\t * A function that maps a Prismic document to a URL within your app.\n\t */\n\tlinkResolver?: LinkResolverFunction<LinkResolverReturnType>;\n\n\t/**\n\t * A fallback URL if the link resolver does not return a value.\n\t */\n\tdefaultURL: string;\n\n\t/**\n\t * The preview token (also known as a ref) that will be used to query preview\n\t * content from the Prismic repository.\n\t */\n\tpreviewToken?: string;\n\n\t/**\n\t * The previewed document that will be used to determine the destination URL.\n\t */\n\tdocumentID?: string;\n};\n\n/**\n * The result of a `fetch()` job.\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ntype FetchJobResult<TJSON = any> = {\n\tstatus: number;\n\tjson: TJSON;\n};\n\n/**\n * Type definitions for the `createClient()` function. May be augmented by\n * third-party libraries.\n */\nexport interface CreateClient {\n\t<TDocuments extends PrismicDocument>(\n\t\t...args: ConstructorParameters<typeof Client>\n\t): Client<TDocuments>;\n}\n\n/**\n * Creates a Prismic client that can be used to query a repository.\n *\n * @example\n *\n * ```ts\n * // With a repository name.\n * createClient(\"qwerty\");\n *\n * // Or with a full Prismic Rest API V2 endpoint.\n * createClient(\"https://qwerty.cdn.prismic.io/api/v2\");\n * ```\n *\n * @typeParam TDocuments - A map of Prismic document type IDs mapped to their\n *   TypeScript type.\n * @param repositoryNameOrEndpoint - The Prismic repository name or full Rest\n *   API V2 endpoint for the repository.\n * @param options - Configuration that determines how content will be queried\n *   from the Prismic repository.\n *\n * @returns A client that can query content from the repository.\n */\nexport const createClient: CreateClient = <TDocuments extends PrismicDocument>(\n\trepositoryNameOrEndpoint: string,\n\toptions?: ClientConfig,\n) => new Client<TDocuments>(repositoryNameOrEndpoint, options);\n\n/**\n * A client that allows querying content from a Prismic repository.\n *\n * If used in an environment where a global `fetch` function is unavailable,\n * such as Node.js, the `fetch` option must be provided as part of the `options`\n * parameter.\n *\n * @typeParam TDocuments - Document types that are registered for the Prismic\n *   repository. Query methods will automatically be typed based on this type.\n */\nexport class Client<TDocuments extends PrismicDocument = PrismicDocument> {\n\t/**\n\t * The Prismic REST API V2 endpoint for the repository (use\n\t * `prismic.getRepositoryEndpoint` for the default endpoint).\n\t */\n\tendpoint: string;\n\n\t/**\n\t * The secure token for accessing the API (only needed if your repository is\n\t * set to private).\n\t *\n\t * {@link https://user-guides.prismic.io/en/articles/1036153-generating-an-access-token}\n\t */\n\taccessToken?: string;\n\n\t/**\n\t * A list of route resolver objects that define how a document's `url` field\n\t * is resolved.\n\t *\n\t * {@link https://prismic.io/docs/route-resolver}\n\t */\n\troutes?: NonNullable<BuildQueryURLArgs[\"routes\"]>;\n\n\t/**\n\t * The `brokenRoute` option allows you to define the route populated in the\n\t * `url` property for broken link or content relationship fields. A broken\n\t * link is a link or content relationship field whose linked document has been\n\t * unpublished or deleted.\n\t *\n\t * {@link https://prismic.io/docs/route-resolver}\n\t */\n\tbrokenRoute?: NonNullable<BuildQueryURLArgs[\"brokenRoute\"]>;\n\n\t/**\n\t * The function used to make network requests to the Prismic REST API. In\n\t * environments where a global `fetch` function does not exist, such as\n\t * Node.js, this function must be provided.\n\t */\n\tfetchFn: FetchLike;\n\n\tfetchOptions?: RequestInitLike;\n\n\t/**\n\t * Default parameters that will be sent with each query. These parameters can\n\t * be overridden on each query if needed.\n\t */\n\tdefaultParams?: Omit<\n\t\tBuildQueryURLArgs,\n\t\t\"ref\" | \"integrationFieldsRef\" | \"accessToken\" | \"routes\"\n\t>;\n\n\t/**\n\t * The client's ref mode state. This determines which ref is used during\n\t * queries.\n\t */\n\tprivate refState: RefState = {\n\t\tmode: RefStateMode.Master,\n\t\tautoPreviewsEnabled: true,\n\t};\n\n\t/**\n\t * Cached repository value.\n\t */\n\tprivate cachedRepository: Repository | undefined;\n\n\t/**\n\t * Timestamp at which the cached repository data is considered stale.\n\t */\n\tprivate cachedRepositoryExpiration = 0;\n\n\t/**\n\t * Active `fetch()` jobs keyed by URL and AbortSignal (if it exists).\n\t */\n\tprivate fetchJobs: Record<\n\t\tstring,\n\t\tMap<AbortSignalLike | undefined, Promise<FetchJobResult>>\n\t> = {};\n\n\t/**\n\t * Creates a Prismic client that can be used to query a repository.\n\t *\n\t * If used in an environment where a global `fetch` function is unavailable,\n\t * such as Node.js, the `fetch` option must be provided as part of the\n\t * `options` parameter.\n\t *\n\t * @param repositoryNameOrEndpoint - The Prismic repository name or full Rest\n\t *   API V2 endpoint for the repository.\n\t * @param options - Configuration that determines how content will be queried\n\t *   from the Prismic repository.\n\t *\n\t * @returns A client that can query content from the repository.\n\t */\n\tconstructor(repositoryNameOrEndpoint: string, options: ClientConfig = {}) {\n\t\tif (isRepositoryEndpoint(repositoryNameOrEndpoint)) {\n\t\t\tif (process.env.NODE_ENV === \"development\") {\n\t\t\t\t// Matches non-API v2 `.prismic.io` endpoints, see: https://regex101.com/r/xRsavu/1\n\t\t\t\tif (/\\.prismic\\.io\\/(?!api\\/v2\\/?)/i.test(repositoryNameOrEndpoint)) {\n\t\t\t\t\tthrow new PrismicError(\n\t\t\t\t\t\t\"@prismicio/client only supports Prismic Rest API V2. Please provide only the repository name to the first createClient() parameter or use the getRepositoryEndpoint() helper to generate a valid Rest API V2 endpoint URL.\",\n\t\t\t\t\t\tundefined,\n\t\t\t\t\t\tundefined,\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\tconst hostname = new URL(\n\t\t\t\t\trepositoryNameOrEndpoint,\n\t\t\t\t).hostname.toLowerCase();\n\n\t\t\t\t// Matches non-.cdn `.prismic.io` endpoints\n\t\t\t\tif (\n\t\t\t\t\thostname.endsWith(\".prismic.io\") &&\n\t\t\t\t\t!hostname.endsWith(\".cdn.prismic.io\")\n\t\t\t\t) {\n\t\t\t\t\tconst repositoryName = getRepositoryName(repositoryNameOrEndpoint);\n\t\t\t\t\tconst dotCDNEndpoint = getRepositoryEndpoint(repositoryName);\n\t\t\t\t\tconsole.warn(\n\t\t\t\t\t\t`[@prismicio/client] A non-.cdn endpoint was provided to create a client with (\\`${repositoryNameOrEndpoint}\\`). Non-.cdn endpoints can have unexpected side-effects and cause performance issues when querying Prismic. Please convert it to the \\`.cdn\\` alternative (\\`${dotCDNEndpoint}\\`) or use the repository name directly instead (\\`${repositoryName}\\`). For more details, see ${devMsg(\n\t\t\t\t\t\t\t\"endpoint-must-use-cdn\",\n\t\t\t\t\t\t)}`,\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis.endpoint = repositoryNameOrEndpoint;\n\t\t} else {\n\t\t\tthis.endpoint = getRepositoryEndpoint(repositoryNameOrEndpoint);\n\t\t}\n\n\t\tthis.accessToken = options.accessToken;\n\t\tthis.routes = options.routes;\n\t\tthis.brokenRoute = options.brokenRoute;\n\t\tthis.fetchOptions = options.fetchOptions;\n\t\tthis.defaultParams = options.defaultParams;\n\n\t\tif (options.ref) {\n\t\t\tthis.queryContentFromRef(options.ref);\n\t\t}\n\n\t\tif (typeof options.fetch === \"function\") {\n\t\t\tthis.fetchFn = options.fetch;\n\t\t} else if (typeof globalThis.fetch === \"function\") {\n\t\t\tthis.fetchFn = globalThis.fetch as FetchLike;\n\t\t} else {\n\t\t\tthrow new PrismicError(\n\t\t\t\t\"A valid fetch implementation was not provided. In environments where fetch is not available (including Node.js), a fetch implementation must be provided via a polyfill or the `fetch` option.\",\n\t\t\t\tundefined,\n\t\t\t\tundefined,\n\t\t\t);\n\t\t}\n\n\t\t// If the global fetch function is used, we must bind it to the global scope.\n\t\tif (this.fetchFn === globalThis.fetch) {\n\t\t\tthis.fetchFn = this.fetchFn.bind(globalThis);\n\t\t}\n\n\t\tthis.graphQLFetch = this.graphQLFetch.bind(this);\n\t}\n\n\t/**\n\t * Enables the client to automatically query content from a preview session if\n\t * one is active in browser environments. This is enabled by default in the\n\t * browser.\n\t *\n\t * For server environments, use `enableAutoPreviewsFromReq`.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * client.enableAutoPreviews();\n\t * ```\n\t *\n\t * @see enableAutoPreviewsFromReq\n\t */\n\tenableAutoPreviews(): void {\n\t\tthis.refState.autoPreviewsEnabled = true;\n\t}\n\n\t/**\n\t * Enables the client to automatically query content from a preview session if\n\t * one is active in server environments. This is disabled by default on the\n\t * server.\n\t *\n\t * For browser environments, use `enableAutoPreviews`.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * // In an express app\n\t * app.get(\"/\", function (req, res) {\n\t * \tclient.enableAutoPreviewsFromReq(req);\n\t * });\n\t * ```\n\t *\n\t * @param req - An HTTP server request object containing the request's\n\t *   cookies.\n\t */\n\tenableAutoPreviewsFromReq<R extends HttpRequestLike>(req: R): void {\n\t\tthis.refState.httpRequest = req;\n\t\tthis.refState.autoPreviewsEnabled = true;\n\t}\n\n\t/**\n\t * Disables the client from automatically querying content from a preview\n\t * session if one is active.\n\t *\n\t * Automatic preview content querying is enabled by default unless this method\n\t * is called.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * client.disableAutoPreviews();\n\t * ```\n\t */\n\tdisableAutoPreviews(): void {\n\t\tthis.refState.autoPreviewsEnabled = false;\n\t}\n\n\t/**\n\t * Queries content from the Prismic repository.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * const response = await client.get();\n\t * ```\n\t *\n\t * @typeParam TDocument - Type of Prismic documents returned.\n\t *\n\t * @param params - Parameters to filter, sort, and paginate results.\n\t *\n\t * @returns A paginated response containing the result of the query.\n\t */\n\tasync get<TDocument extends TDocuments>(\n\t\tparams?: Partial<BuildQueryURLArgs> & FetchParams,\n\t): Promise<Query<TDocument>> {\n\t\tconst url = await this.buildQueryURL(params);\n\n\t\treturn await this.fetch<Query<TDocument>>(url, params);\n\t}\n\n\t/**\n\t * Queries content from the Prismic repository and returns only the first\n\t * result, if any.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * const document = await client.getFirst();\n\t * ```\n\t *\n\t * @typeParam TDocument - Type of the Prismic document returned.\n\t *\n\t * @param params - Parameters to filter, sort, and paginate results. @returns\n\t *   The first result of the query, if any.\n\t */\n\tasync getFirst<TDocument extends TDocuments>(\n\t\tparams?: Partial<BuildQueryURLArgs> & FetchParams,\n\t): Promise<TDocument> {\n\t\tconst actualParams = { ...params };\n\t\tif (!(params && params.page) && !params?.pageSize) {\n\t\t\tactualParams.pageSize = this.defaultParams?.pageSize ?? 1;\n\t\t}\n\t\tconst url = await this.buildQueryURL(actualParams);\n\t\tconst result = await this.fetch<Query<TDocument>>(url, params);\n\n\t\tconst firstResult = result.results[0];\n\n\t\tif (firstResult) {\n\t\t\treturn firstResult;\n\t\t}\n\n\t\tthrow new PrismicError(\"No documents were returned\", url, undefined);\n\t}\n\n\t/**\n\t * **IMPORTANT**: Avoid using `dangerouslyGetAll` as it may be slower and\n\t * require more resources than other methods. Prefer using other methods that\n\t * filter by filters such as `getAllByType`.\n\t *\n\t * Queries content from the Prismic repository and returns all matching\n\t * content. If no filters are provided, all documents will be fetched.\n\t *\n\t * This method may make multiple network requests to query all matching\n\t * content.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * const response = await client.dangerouslyGetAll();\n\t * ```\n\t *\n\t * @typeParam TDocument - Type of Prismic documents returned.\n\t *\n\t * @param params - Parameters to filter, sort, and paginate results.\n\t *\n\t * @returns A list of documents matching the query.\n\t */\n\tasync dangerouslyGetAll<TDocument extends TDocuments>(\n\t\tparams: Partial<Omit<BuildQueryURLArgs, \"page\">> &\n\t\t\tGetAllParams &\n\t\t\tFetchParams = {},\n\t): Promise<TDocument[]> {\n\t\tconst { limit = Infinity, ...actualParams } = params;\n\t\tconst resolvedParams = {\n\t\t\t...actualParams,\n\t\t\tpageSize: Math.min(\n\t\t\t\tlimit,\n\t\t\t\tactualParams.pageSize || this.defaultParams?.pageSize || MAX_PAGE_SIZE,\n\t\t\t),\n\t\t};\n\n\t\tconst documents: TDocument[] = [];\n\t\tlet latestResult: Query<TDocument> | undefined;\n\n\t\twhile (\n\t\t\t(!latestResult || latestResult.next_page) &&\n\t\t\tdocuments.length < limit\n\t\t) {\n\t\t\tconst page = latestResult ? latestResult.page + 1 : undefined;\n\n\t\t\tlatestResult = await this.get<TDocument>({ ...resolvedParams, page });\n\t\t\tdocuments.push(...latestResult.results);\n\n\t\t\tif (latestResult.next_page) {\n\t\t\t\tawait new Promise((res) => setTimeout(res, GET_ALL_QUERY_DELAY));\n\t\t\t}\n\t\t}\n\n\t\treturn documents.slice(0, limit);\n\t}\n\n\t/**\n\t * Queries a document from the Prismic repository with a specific ID.\n\t *\n\t * @remarks\n\t * A document's UID is different from its ID. An ID is automatically generated\n\t * for all documents and is made available on its `id` property. A UID is\n\t * provided in the Prismic editor and is unique among all documents of its\n\t * custom type.\n\t * @example\n\t *\n\t * ```ts\n\t * const document = await client.getByID(\"WW4bKScAAMAqmluX\");\n\t * ```\n\t *\n\t * @typeParam TDocument- Type of the Prismic document returned.\n\t *\n\t * @param id - ID of the document.\n\t * @param params - Parameters to filter, sort, and paginate the results.\n\t *\n\t * @returns The document with an ID matching the `id` parameter, if a matching\n\t *   document exists.\n\t */\n\tasync getByID<TDocument extends TDocuments>(\n\t\tid: string,\n\t\tparams?: Partial<BuildQueryURLArgs> & FetchParams,\n\t): Promise<TDocument> {\n\t\treturn await this.getFirst<TDocument>(\n\t\t\tappendFilters(params, filter.at(\"document.id\", id)),\n\t\t);\n\t}\n\n\t/**\n\t * Queries documents from the Prismic repository with specific IDs.\n\t *\n\t * @remarks\n\t * A document's UID is different from its ID. An ID is automatically generated\n\t * for all documents and is made available on its `id` property. A UID is\n\t * provided in the Prismic editor and is unique among all documents of its\n\t * custom type.\n\t * @example\n\t *\n\t * ```ts\n\t * const response = await client.getByIDs([\n\t * \t\"WW4bKScAAMAqmluX\",\n\t * \t\"U1kTRgEAAC8A5ldS\",\n\t * ]);\n\t * ```\n\t *\n\t * @typeParam TDocument - Type of Prismic documents returned.\n\t *\n\t * @param ids - A list of document IDs.\n\t * @param params - Parameters to filter, sort, and paginate the results.\n\t *\n\t * @returns A paginated response containing documents with IDs matching the\n\t *   `ids` parameter.\n\t */\n\tasync getByIDs<TDocument extends TDocuments>(\n\t\tids: string[],\n\t\tparams?: Partial<BuildQueryURLArgs> & FetchParams,\n\t): Promise<Query<TDocument>> {\n\t\treturn await this.get<TDocument>(\n\t\t\tappendFilters(params, filter.in(\"document.id\", ids)),\n\t\t);\n\t}\n\n\t/**\n\t * Queries all documents from the Prismic repository with specific IDs.\n\t *\n\t * This method may make multiple network requests to query all matching\n\t * content.\n\t *\n\t * @remarks\n\t * A document's UID is different from its ID. An ID is automatically generated\n\t * for all documents and is made available on its `id` property. A UID is\n\t * provided in the Prismic editor and is unique among all documents of its\n\t * custom type.\n\t * @example\n\t *\n\t * ```ts\n\t * const response = await client.getAllByIDs([\n\t * \t\"WW4bKScAAMAqmluX\",\n\t * \t\"U1kTRgEAAC8A5ldS\",\n\t * ]);\n\t * ```\n\t *\n\t * @typeParam TDocument - Type of Prismic documents returned.\n\t *\n\t * @param ids - A list of document IDs.\n\t * @param params - Parameters to filter, sort, and paginate the results.\n\t *\n\t * @returns A list of documents with IDs matching the `ids` parameter.\n\t */\n\tasync getAllByIDs<TDocument extends TDocuments>(\n\t\tids: string[],\n\t\tparams?: Partial<BuildQueryURLArgs> & GetAllParams & FetchParams,\n\t): Promise<TDocument[]> {\n\t\treturn await this.dangerouslyGetAll<TDocument>(\n\t\t\tappendFilters(params, filter.in(\"document.id\", ids)),\n\t\t);\n\t}\n\n\t/**\n\t * Queries a document from the Prismic repository with a specific UID and\n\t * custom type.\n\t *\n\t * @remarks\n\t * A document's UID is different from its ID. An ID is automatically generated\n\t * for all documents and is made available on its `id` property. A UID is\n\t * provided in the Prismic editor and is unique among all documents of its\n\t * custom type.\n\t * @example\n\t *\n\t * ```ts\n\t * const document = await client.getByUID(\"blog_post\", \"my-first-post\");\n\t * ```\n\t *\n\t * @typeParam TDocument - Type of the Prismic document returned.\n\t *\n\t * @param documentType - The API ID of the document's custom type.\n\t * @param uid - UID of the document.\n\t * @param params - Parameters to filter, sort, and paginate the results.\n\t *\n\t * @returns The document with a UID matching the `uid` parameter, if a\n\t *   matching document exists.\n\t */\n\tasync getByUID<\n\t\tTDocument extends TDocuments,\n\t\tTDocumentType extends TDocument[\"type\"] = TDocument[\"type\"],\n\t>(\n\t\tdocumentType: TDocumentType,\n\t\tuid: string,\n\t\tparams?: Partial<BuildQueryURLArgs> & FetchParams,\n\t): Promise<ExtractDocumentType<TDocument, TDocumentType>> {\n\t\treturn await this.getFirst<ExtractDocumentType<TDocument, TDocumentType>>(\n\t\t\tappendFilters(params, [\n\t\t\t\ttypeFilter(documentType),\n\t\t\t\tfilter.at(`my.${documentType}.uid`, uid),\n\t\t\t]),\n\t\t);\n\t}\n\n\t/**\n\t * Queries document from the Prismic repository with specific UIDs and Custom\n\t * Type.\n\t *\n\t * @remarks\n\t * A document's UID is different from its ID. An ID is automatically generated\n\t * for all documents and is made available on its `id` property. A UID is\n\t * provided in the Prismic editor and is unique among all documents of its\n\t * custom type.\n\t * @example\n\t *\n\t * ```ts\n\t * const document = await client.getByUIDs(\"blog_post\", [\n\t * \t\"my-first-post\",\n\t * \t\"my-second-post\",\n\t * ]);\n\t * ```\n\t *\n\t * @typeParam TDocument - Type of the Prismic document returned.\n\t *\n\t * @param documentType - The API ID of the document's custom type.\n\t * @param uids - A list of document UIDs.\n\t * @param params - Parameters to filter, sort, and paginate the results.\n\t *\n\t * @returns A paginated response containing documents with UIDs matching the\n\t *   `uids` parameter.\n\t */\n\tasync getByUIDs<\n\t\tTDocument extends TDocuments,\n\t\tTDocumentType extends TDocument[\"type\"] = TDocument[\"type\"],\n\t>(\n\t\tdocumentType: TDocumentType,\n\t\tuids: string[],\n\t\tparams?: Partial<BuildQueryURLArgs> & FetchParams,\n\t): Promise<Query<ExtractDocumentType<TDocument, TDocumentType>>> {\n\t\treturn await this.get<ExtractDocumentType<TDocument, TDocumentType>>(\n\t\t\tappendFilters(params, [\n\t\t\t\ttypeFilter(documentType),\n\t\t\t\tfilter.in(`my.${documentType}.uid`, uids),\n\t\t\t]),\n\t\t);\n\t}\n\n\t/**\n\t * Queries all documents from the Prismic repository with specific UIDs and\n\t * custom type.\n\t *\n\t * This method may make multiple network requests to query all matching\n\t * content.\n\t *\n\t * @remarks\n\t * A document's UID is different from its ID. An ID is automatically generated\n\t * for all documents and is made available on its `id` property. A UID is\n\t * provided in the Prismic editor and is unique among all documents of its\n\t * custom type.\n\t * @example\n\t *\n\t * ```ts\n\t * const response = await client.getAllByUIDs([\n\t * \t\"my-first-post\",\n\t * \t\"my-second-post\",\n\t * ]);\n\t * ```\n\t *\n\t * @typeParam TDocument - Type of Prismic documents returned.\n\t *\n\t * @param documentType - The API ID of the document's custom type.\n\t * @param uids - A list of document UIDs.\n\t * @param params - Parameters to filter, sort, and paginate the results.\n\t *\n\t * @returns A list of documents with UIDs matching the `uids` parameter.\n\t */\n\tasync getAllByUIDs<\n\t\tTDocument extends TDocuments,\n\t\tTDocumentType extends TDocument[\"type\"] = TDocument[\"type\"],\n\t>(\n\t\tdocumentType: TDocumentType,\n\t\tuids: string[],\n\t\tparams?: Partial<BuildQueryURLArgs> & GetAllParams & FetchParams,\n\t): Promise<ExtractDocumentType<TDocument, TDocumentType>[]> {\n\t\treturn await this.dangerouslyGetAll<\n\t\t\tExtractDocumentType<TDocument, TDocumentType>\n\t\t>(\n\t\t\tappendFilters(params, [\n\t\t\t\ttypeFilter(documentType),\n\t\t\t\tfilter.in(`my.${documentType}.uid`, uids),\n\t\t\t]),\n\t\t);\n\t}\n\n\t/**\n\t * Queries a singleton document from the Prismic repository for a specific\n\t * custom type.\n\t *\n\t * @remarks\n\t * A singleton document is one that is configured in Prismic to only allow one\n\t * instance. For example, a repository may be configured to contain just one\n\t * Settings document. This is in contrast to a repeatable custom type which\n\t * allows multiple instances of itself.\n\t * @example\n\t *\n\t * ```ts\n\t * const document = await client.getSingle(\"settings\");\n\t * ```\n\t *\n\t * @typeParam TDocument - Type of the Prismic document returned.\n\t *\n\t * @param documentType - The API ID of the singleton custom type.\n\t * @param params - Parameters to filter, sort, and paginate the results.\n\t *\n\t * @returns The singleton document for the custom type, if a matching document\n\t *   exists.\n\t */\n\tasync getSingle<\n\t\tTDocument extends TDocuments,\n\t\tTDocumentType extends TDocument[\"type\"] = TDocument[\"type\"],\n\t>(\n\t\tdocumentType: TDocumentType,\n\t\tparams?: Partial<BuildQueryURLArgs> & FetchParams,\n\t): Promise<ExtractDocumentType<TDocument, TDocumentType>> {\n\t\treturn await this.getFirst<ExtractDocumentType<TDocument, TDocumentType>>(\n\t\t\tappendFilters(params, typeFilter(documentType)),\n\t\t);\n\t}\n\n\t/**\n\t * Queries documents from the Prismic repository for a specific custom type.\n\t *\n\t * Use `getAllByType` instead if you need to query all documents for a\n\t * specific custom type.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * const response = await client.getByType(\"blog_post\");\n\t * ```\n\t *\n\t * @typeParam TDocument - Type of Prismic documents returned.\n\t *\n\t * @param documentType - The API ID of the custom type.\n\t * @param params - Parameters to filter, sort, and paginate the results.\n\t *\n\t * @returns A paginated response containing documents of the custom type.\n\t */\n\tasync getByType<\n\t\tTDocument extends TDocuments,\n\t\tTDocumentType extends TDocument[\"type\"] = TDocument[\"type\"],\n\t>(\n\t\tdocumentType: TDocumentType,\n\t\tparams?: Partial<BuildQueryURLArgs> & FetchParams,\n\t): Promise<Query<ExtractDocumentType<TDocument, TDocumentType>>> {\n\t\treturn await this.get<ExtractDocumentType<TDocument, TDocumentType>>(\n\t\t\tappendFilters(params, typeFilter(documentType)),\n\t\t);\n\t}\n\n\t/**\n\t * Queries all documents from the Prismic repository for a specific Custom\n\t * Type.\n\t *\n\t * This method may make multiple network requests to query all matching\n\t * content.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * const response = await client.getByType(\"blog_post\");\n\t * ```\n\t *\n\t * @typeParam TDocument - Type of Prismic documents returned.\n\t *\n\t * @param documentType - The API ID of the custom type.\n\t * @param params - Parameters to filter, sort, and paginate the results.\n\t *\n\t * @returns A list of all documents of the custom type.\n\t */\n\tasync getAllByType<\n\t\tTDocument extends TDocuments,\n\t\tTDocumentType extends TDocument[\"type\"] = TDocument[\"type\"],\n\t>(\n\t\tdocumentType: TDocumentType,\n\t\tparams?: Partial<Omit<BuildQueryURLArgs, \"page\">> &\n\t\t\tGetAllParams &\n\t\t\tFetchParams,\n\t): Promise<ExtractDocumentType<TDocument, TDocumentType>[]> {\n\t\treturn await this.dangerouslyGetAll<\n\t\t\tExtractDocumentType<TDocument, TDocumentType>\n\t\t>(appendFilters(params, typeFilter(documentType)));\n\t}\n\n\t/**\n\t * Queries documents from the Prismic repository with a specific tag.\n\t *\n\t * Use `getAllByTag` instead if you need to query all documents with a\n\t * specific tag.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * const response = await client.getByTag(\"food\");\n\t * ```\n\t *\n\t * @typeParam TDocument - Type of Prismic documents returned.\n\t *\n\t * @param tag - The tag that must be included on a document.\n\t * @param params - Parameters to filter, sort, and paginate the results.\n\t *\n\t * @returns A paginated response containing documents with the tag.\n\t */\n\tasync getByTag<TDocument extends TDocuments>(\n\t\ttag: string,\n\t\tparams?: Partial<BuildQueryURLArgs> & FetchParams,\n\t): Promise<Query<TDocument>> {\n\t\treturn await this.get<TDocument>(\n\t\t\tappendFilters(params, someTagsFilter(tag)),\n\t\t);\n\t}\n\n\t/**\n\t * Queries all documents from the Prismic repository with a specific tag.\n\t *\n\t * This method may make multiple network requests to query all matching\n\t * content.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * const response = await client.getAllByTag(\"food\");\n\t * ```\n\t *\n\t * @typeParam TDocument - Type of Prismic documents returned.\n\t *\n\t * @param tag - The tag that must be included on a document.\n\t * @param params - Parameters to filter, sort, and paginate the results.\n\t *\n\t * @returns A list of all documents with the tag.\n\t */\n\tasync getAllByTag<TDocument extends TDocuments>(\n\t\ttag: string,\n\t\tparams?: Partial<Omit<BuildQueryURLArgs, \"page\">> &\n\t\t\tGetAllParams &\n\t\t\tFetchParams,\n\t): Promise<TDocument[]> {\n\t\treturn await this.dangerouslyGetAll<TDocument>(\n\t\t\tappendFilters(params, someTagsFilter(tag)),\n\t\t);\n\t}\n\n\t/**\n\t * Queries documents from the Prismic repository with specific tags. A\n\t * document must be tagged with all of the queried tags to be included.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * const response = await client.getByEveryTag([\"food\", \"fruit\"]);\n\t * ```\n\t *\n\t * @typeParam TDocument - Type of Prismic documents returned.\n\t *\n\t * @param tags - A list of tags that must be included on a document.\n\t * @param params - Parameters to filter, sort, and paginate the results.\n\t *\n\t * @returns A paginated response containing documents with the tags.\n\t */\n\tasync getByEveryTag<TDocument extends TDocuments>(\n\t\ttags: string[],\n\t\tparams?: Partial<BuildQueryURLArgs> & FetchParams,\n\t): Promise<Query<TDocument>> {\n\t\treturn await this.get<TDocument>(\n\t\t\tappendFilters(params, everyTagFilter(tags)),\n\t\t);\n\t}\n\n\t/**\n\t * Queries documents from the Prismic repository with specific tags. A\n\t * document must be tagged with all of the queried tags to be included.\n\t *\n\t * This method may make multiple network requests to query all matching\n\t * content.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * const response = await client.getAllByEveryTag([\"food\", \"fruit\"]);\n\t * ```\n\t *\n\t * @typeParam TDocument - Type of Prismic documents returned.\n\t *\n\t * @param tags - A list of tags that must be included on a document.\n\t * @param params - Parameters to filter, sort, and paginate the results.\n\t *\n\t * @returns A list of all documents with the tags.\n\t */\n\tasync getAllByEveryTag<TDocument extends TDocuments>(\n\t\ttags: string[],\n\t\tparams?: Partial<Omit<BuildQueryURLArgs, \"page\">> &\n\t\t\tGetAllParams &\n\t\t\tFetchParams,\n\t): Promise<TDocument[]> {\n\t\treturn await this.dangerouslyGetAll<TDocument>(\n\t\t\tappendFilters(params, everyTagFilter(tags)),\n\t\t);\n\t}\n\n\t/**\n\t * Queries documents from the Prismic repository with specific tags. A\n\t * document must be tagged with at least one of the queried tags to be\n\t * included.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * const response = await client.getByEveryTag([\"food\", \"fruit\"]);\n\t * ```\n\t *\n\t * @typeParam TDocument - Type of Prismic documents returned.\n\t *\n\t * @param tags - A list of tags that must be included on a document.\n\t * @param params - Parameters to filter, sort, and paginate the results.\n\t *\n\t * @returns A paginated response containing documents with at least one of the\n\t *   tags.\n\t */\n\tasync getBySomeTags<TDocument extends TDocuments>(\n\t\ttags: string[],\n\t\tparams?: Partial<BuildQueryURLArgs> & FetchParams,\n\t): Promise<Query<TDocument>> {\n\t\treturn await this.get<TDocument>(\n\t\t\tappendFilters(params, someTagsFilter(tags)),\n\t\t);\n\t}\n\n\t/**\n\t * Queries documents from the Prismic repository with specific tags. A\n\t * document must be tagged with at least one of the queried tags to be\n\t * included.\n\t *\n\t * This method may make multiple network requests to query all matching\n\t * content.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * const response = await client.getAllBySomeTags([\"food\", \"fruit\"]);\n\t * ```\n\t *\n\t * @typeParam TDocument - Type of Prismic documents returned.\n\t *\n\t * @param tags - A list of tags that must be included on a document.\n\t * @param params - Parameters to filter, sort, and paginate the results.\n\t *\n\t * @returns A list of all documents with at least one of the tags.\n\t */\n\tasync getAllBySomeTags<TDocument extends TDocuments>(\n\t\ttags: string[],\n\t\tparams?: Partial<Omit<BuildQueryURLArgs, \"page\">> &\n\t\t\tGetAllParams &\n\t\t\tFetchParams,\n\t): Promise<TDocument[]> {\n\t\treturn await this.dangerouslyGetAll<TDocument>(\n\t\t\tappendFilters(params, someTagsFilter(tags)),\n\t\t);\n\t}\n\n\t/**\n\t * Returns metadata about the Prismic repository, such as its refs, releases,\n\t * and custom types.\n\t *\n\t * @returns Repository metadata.\n\t */\n\tasync getRepository(params?: FetchParams): Promise<Repository> {\n\t\t// TODO: Restore when Authorization header support works in browsers with CORS.\n\t\t// return await this.fetch<Repository>(this.endpoint);\n\n\t\tconst url = new URL(this.endpoint);\n\n\t\tif (this.accessToken) {\n\t\t\turl.searchParams.set(\"access_token\", this.accessToken);\n\t\t}\n\n\t\treturn await this.fetch<Repository>(url.toString(), params);\n\t}\n\n\t/**\n\t * Returns a list of all refs for the Prismic repository.\n\t *\n\t * Refs are used to identify which version of the repository's content should\n\t * be queried. All repositories will have at least one ref pointing to the\n\t * latest published content called the \"master ref\".\n\t *\n\t * @returns A list of all refs for the Prismic repository.\n\t */\n\tasync getRefs(params?: FetchParams): Promise<Ref[]> {\n\t\tconst repository = await this.getRepository(params);\n\n\t\treturn repository.refs;\n\t}\n\n\t/**\n\t * Returns a ref for the Prismic repository with a matching ID.\n\t *\n\t * @param id - ID of the ref.\n\t *\n\t * @returns The ref with a matching ID, if it exists.\n\t */\n\tasync getRefByID(id: string, params?: FetchParams): Promise<Ref> {\n\t\tconst refs = await this.getRefs(params);\n\n\t\treturn findRefByID(refs, id);\n\t}\n\n\t/**\n\t * Returns a ref for the Prismic repository with a matching label.\n\t *\n\t * @param label - Label of the ref.\n\t *\n\t * @returns The ref with a matching label, if it exists.\n\t */\n\tasync getRefByLabel(label: string, params?: FetchParams): Promise<Ref> {\n\t\tconst refs = await this.getRefs(params);\n\n\t\treturn findRefByLabel(refs, label);\n\t}\n\n\t/**\n\t * Returns the master ref for the Prismic repository. The master ref points to\n\t * the repository's latest published content.\n\t *\n\t * @returns The repository's master ref.\n\t */\n\tasync getMasterRef(params?: FetchParams): Promise<Ref> {\n\t\tconst refs = await this.getRefs(params);\n\n\t\treturn findMasterRef(refs);\n\t}\n\n\t/**\n\t * Returns a list of all Releases for the Prismic repository. Releases are\n\t * used to group content changes before publishing.\n\t *\n\t * @returns A list of all Releases for the Prismic repository.\n\t */\n\tasync getReleases(params?: FetchParams): Promise<Ref[]> {\n\t\tconst refs = await this.getRefs(params);\n\n\t\treturn refs.filter((ref) => !ref.isMasterRef);\n\t}\n\n\t/**\n\t * Returns a Release for the Prismic repository with a matching ID.\n\t *\n\t * @param id - ID of the Release.\n\t *\n\t * @returns The Release with a matching ID, if it exists.\n\t */\n\tasync getReleaseByID(id: string, params?: FetchParams): Promise<Ref> {\n\t\tconst releases = await this.getReleases(params);\n\n\t\treturn findRefByID(releases, id);\n\t}\n\n\t/**\n\t * Returns a Release for the Prismic repository with a matching label.\n\t *\n\t * @param label - Label of the ref.\n\t *\n\t * @returns The ref with a matching label, if it exists.\n\t */\n\tasync getReleaseByLabel(label: string, params?: FetchParams): Promise<Ref> {\n\t\tconst releases = await this.getReleases(params);\n\n\t\treturn findRefByLabel(releases, label);\n\t}\n\n\t/**\n\t * Returns a list of all tags used in the Prismic repository.\n\t *\n\t * @returns A list of all tags used in the repository.\n\t */\n\tasync getTags(params?: FetchParams): Promise<string[]> {\n\t\ttry {\n\t\t\tconst tagsForm = await this.getCachedRepositoryForm(\"tags\", params);\n\n\t\t\tconst url = new URL(tagsForm.action);\n\n\t\t\tif (this.accessToken) {\n\t\t\t\turl.searchParams.set(\"access_token\", this.accessToken);\n\t\t\t}\n\n\t\t\treturn await this.fetch<string[]>(url.toString(), params);\n\t\t} catch {\n\t\t\tconst repository = await this.getRepository(params);\n\n\t\t\treturn repository.tags;\n\t\t}\n\t}\n\n\t/**\n\t * Builds a URL used to query content from the Prismic repository.\n\t *\n\t * @param params - Parameters to filter, sort, and paginate the results.\n\t *\n\t * @returns A URL string that can be requested to query content.\n\t */\n\tasync buildQueryURL({\n\t\tsignal,\n\t\tfetchOptions,\n\t\t...params\n\t}: Partial<BuildQueryURLArgs> & FetchParams = {}): Promise<string> {\n\t\tconst ref =\n\t\t\tparams.ref || (await this.getResolvedRefString({ signal, fetchOptions }));\n\t\tconst integrationFieldsRef =\n\t\t\tparams.integrationFieldsRef ||\n\t\t\t(await this.getCachedRepository({ signal, fetchOptions }))\n\t\t\t\t.integrationFieldsRef ||\n\t\t\tundefined;\n\n\t\treturn buildQueryURL(this.endpoint, {\n\t\t\t...this.defaultParams,\n\t\t\t...params,\n\t\t\tref,\n\t\t\tintegrationFieldsRef,\n\t\t\troutes: params.routes || this.routes,\n\t\t\tbrokenRoute: params.brokenRoute || this.brokenRoute,\n\t\t\taccessToken: params.accessToken || this.accessToken,\n\t\t});\n\t}\n\n\t/**\n\t * Determines the URL for a previewed document during an active preview\n\t * session. The result of this method should be used to redirect the user to\n\t * the document's URL.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * \tconst url = client.resolvePreviewURL({\n\t * \tlinkResolver: (document) => `/${document.uid}`\n\t * \tdefaultURL: '/'\n\t * \t})\n\t * ```\n\t *\n\t * @param args - Arguments to configure the URL resolving.\n\t *\n\t * @returns The URL for the previewed document during an active preview\n\t *   session. The user should be redirected to this URL.\n\t */\n\tasync resolvePreviewURL<LinkResolverReturnType>(\n\t\targs: ResolvePreviewArgs<LinkResolverReturnType> & FetchParams,\n\t): Promise<string> {\n\t\tlet documentID: string | undefined | null = args.documentID;\n\t\tlet previewToken: string | undefined | null = args.previewToken;\n\n\t\tif (typeof globalThis.location !== \"undefined\") {\n\t\t\tconst searchParams = new URLSearchParams(globalThis.location.search);\n\n\t\t\tdocumentID = documentID || searchParams.get(\"documentId\");\n\t\t\tpreviewToken = previewToken || searchParams.get(\"token\");\n\t\t} else if (this.refState.httpRequest) {\n\t\t\tif (\"query\" in this.refState.httpRequest) {\n\t\t\t\tdocumentID =\n\t\t\t\t\tdocumentID || (this.refState.httpRequest.query?.documentId as string);\n\t\t\t\tpreviewToken =\n\t\t\t\t\tpreviewToken || (this.refState.httpRequest.query?.token as string);\n\t\t\t} else if (\n\t\t\t\t\"url\" in this.refState.httpRequest &&\n\t\t\t\tthis.refState.httpRequest.url\n\t\t\t) {\n\t\t\t\t// Including \"missing-host://\" by default\n\t\t\t\t// handles a case where Next.js Route Handlers\n\t\t\t\t// only provide the pathname and search\n\t\t\t\t// parameters in the `url` property\n\t\t\t\t// (e.g. `/api/preview?foo=bar`).\n\t\t\t\tconst searchParams = new URL(\n\t\t\t\t\tthis.refState.httpRequest.url,\n\t\t\t\t\t\"missing-host://\",\n\t\t\t\t).searchParams;\n\n\t\t\t\tdocumentID = documentID || searchParams.get(\"documentId\");\n\t\t\t\tpreviewToken = previewToken || searchParams.get(\"token\");\n\t\t\t}\n\t\t}\n\n\t\tif (documentID != null && previewToken != null) {\n\t\t\tconst document = await this.getByID(documentID, {\n\t\t\t\tref: previewToken,\n\t\t\t\tlang: \"*\",\n\t\t\t\tsignal: args.signal,\n\t\t\t\tfetchOptions: args.fetchOptions,\n\t\t\t});\n\n\t\t\tconst url = asLink(document, { linkResolver: args.linkResolver });\n\n\t\t\tif (typeof url === \"string\") {\n\t\t\t\treturn url;\n\t\t\t}\n\t\t}\n\n\t\treturn args.defaultURL;\n\t}\n\n\t/**\n\t * Configures the client to query the latest published content for all future\n\t * queries.\n\t *\n\t * If the `ref` parameter is provided during a query, it takes priority for\n\t * that query.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * await client.queryLatestContent();\n\t * const document = await client.getByID(\"WW4bKScAAMAqmluX\");\n\t * ```\n\t */\n\tqueryLatestContent(): void {\n\t\tthis.refState.mode = RefStateMode.Master;\n\t}\n\n\t/**\n\t * Configures the client to query content from a specific Release identified\n\t * by its ID for all future queries.\n\t *\n\t * If the `ref` parameter is provided during a query, it takes priority for\n\t * that query.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * await client.queryContentFromReleaseByID(\"YLB7OBAAACMA7Cpa\");\n\t * const document = await client.getByID(\"WW4bKScAAMAqmluX\");\n\t * ```\n\t *\n\t * @param releaseID - The ID of the Release.\n\t */\n\tqueryContentFromReleaseByID(releaseID: string): void {\n\t\tthis.refState = {\n\t\t\t...this.refState,\n\t\t\tmode: RefStateMode.ReleaseID,\n\t\t\treleaseID,\n\t\t};\n\t}\n\n\t/**\n\t * Configures the client to query content from a specific Release identified\n\t * by its label for all future queries.\n\t *\n\t * If the `ref` parameter is provided during a query, it takes priority for\n\t * that query.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * await client.queryContentFromReleaseByLabel(\"My Release\");\n\t * const document = await client.getByID(\"WW4bKScAAMAqmluX\");\n\t * ```\n\t *\n\t * @param releaseLabel - The label of the Release.\n\t */\n\tqueryContentFromReleaseByLabel(releaseLabel: string): void {\n\t\tthis.refState = {\n\t\t\t...this.refState,\n\t\t\tmode: RefStateMode.ReleaseLabel,\n\t\t\treleaseLabel,\n\t\t};\n\t}\n\n\t/**\n\t * Configures the client to query content from a specific ref. The ref can be\n\t * provided as a string or a function.\n\t *\n\t * If a function is provided, the ref is fetched lazily before each query. The\n\t * function may also be asynchronous.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * await client.queryContentFromRef(\"my-ref\");\n\t * const document = await client.getByID(\"WW4bKScAAMAqmluX\");\n\t * ```\n\t *\n\t * @param ref - The ref or a function that returns the ref from which to query\n\t *   content.\n\t */\n\tqueryContentFromRef(ref: RefStringOrThunk): void {\n\t\tthis.refState = {\n\t\t\t...this.refState,\n\t\t\tmode: RefStateMode.Manual,\n\t\t\tref,\n\t\t};\n\t}\n\n\t/**\n\t * A `fetch()` function to be used with GraphQL clients configured for\n\t * Prismic's GraphQL API. It automatically applies the necessary `prismic-ref`\n\t * and Authorization headers. Queries will automatically be minified by\n\t * removing whitespace where possible.\n\t *\n\t * @example\n\t *\n\t * ```ts\n\t * const graphQLClient = new ApolloClient({\n\t * \tlink: new HttpLink({\n\t * \t\turi: prismic.getGraphQLEndpoint(repositoryName),\n\t * \t\t// Provide `client.graphQLFetch` as the fetch implementation.\n\t * \t\tfetch: client.graphQLFetch,\n\t * \t\t// Using GET is required.\n\t * \t\tuseGETForQueries: true,\n\t * \t}),\n\t * \tcache: new InMemoryCache(),\n\t * });\n\t * ```\n\t *\n\t * @param input - The `fetch()` `input` parameter. Only strings are supported.\n\t * @param init - The `fetch()` `init` parameter. Only plain objects are\n\t *   supported.\n\t *\n\t * @returns The `fetch()` Response for the request.\n\t *\n\t * @experimental\n\t */\n\tasync graphQLFetch(\n\t\tinput: RequestInfo,\n\t\tinit?: Omit<RequestInit, \"signal\"> & { signal?: AbortSignalLike },\n\t): Promise<Response> {\n\t\tconst cachedRepository = await this.getCachedRepository();\n\t\tconst ref = await this.getResolvedRefString();\n\n\t\tconst unsanitizedHeaders: Record<string, string> = {\n\t\t\t\"Prismic-ref\": ref,\n\t\t\tAuthorization: this.accessToken ? `Token ${this.accessToken}` : \"\",\n\t\t\t// Asserting `init.headers` is a Record since popular GraphQL\n\t\t\t// libraries pass this as a Record. Header objects as input\n\t\t\t// are unsupported.\n\t\t\t...(init ? (init.headers as Record<string, string>) : {}),\n\t\t};\n\n\t\tif (cachedRepository.integrationFieldsRef) {\n\t\t\tunsanitizedHeaders[\"Prismic-integration-field-ref\"] =\n\t\t\t\tcachedRepository.integrationFieldsRef;\n\t\t}\n\n\t\t// Normalize header keys to lowercase. This prevents header\n\t\t// conflicts between the Prismic client and the GraphQL\n\t\t// client.\n\t\tconst headers: Record<string, string> = {};\n\t\tfor (const key in unsanitizedHeaders) {\n\t\t\tif (unsanitizedHeaders[key]) {\n\t\t\t\theaders[key.toLowerCase()] =\n\t\t\t\t\tunsanitizedHeaders[key as keyof typeof unsanitizedHeaders];\n\t\t\t}\n\t\t}\n\n\t\tconst url = new URL(\n\t\t\t// Asserting `input` is a string since popular GraphQL\n\t\t\t// libraries pass this as a string. Request objects as\n\t\t\t// input are unsupported.\n\t\t\tinput as string,\n\t\t);\n\n\t\t// This prevents the request from being cached unnecessarily.\n\t\t// Without adding this `ref` param, re-running a query\n\t\t// could return a locally cached response, even if the\n\t\t// `ref` changed. This happens because the URL is\n\t\t// identical when the `ref` is not included. Caches may ignore\n\t\t// headers.\n\t\t//\n\t\t// The Prismic GraphQL API ignores the `ref` param.\n\t\turl.searchParams.set(\"ref\", ref);\n\n\t\tconst query = url.searchParams.get(\"query\");\n\t\tif (query) {\n\t\t\turl.searchParams.set(\n\t\t\t\t\"query\",\n\t\t\t\t// Compress the GraphQL query (if it exists) by\n\t\t\t\t// removing whitespace. This is done to\n\t\t\t\t// optimize the query size and avoid\n\t\t\t\t// hitting the upper limit of GET requests\n\t\t\t\t// (2048 characters).\n\t\t\t\tminifyGraphQLQuery(query),\n\t\t\t);\n\t\t}\n\n\t\treturn (await this.fetchFn(url.toString(), {\n\t\t\t...init,\n\t\t\theaders,\n\t\t})) as Response;\n\t}\n\n\t/**\n\t * Returns a cached version of `getRepository` with a TTL.\n\t *\n\t * @returns Cached repository metadata.\n\t */\n\tprivate async getCachedRepository(params?: FetchParams): Promise<Repository> {\n\t\tif (\n\t\t\t!this.cachedRepository ||\n\t\t\tDate.now() >= this.cachedRepositoryExpiration\n\t\t) {\n\t\t\tthis.cachedRepositoryExpiration = Date.now() + REPOSITORY_CACHE_TTL;\n\t\t\tthis.cachedRepository = await this.getRepository(params);\n\t\t}\n\n\t\treturn this.cachedRepository;\n\t}\n\n\t/**\n\t * Returns a cached Prismic repository form. Forms are used to determine API\n\t * endpoints for types of repository data.\n\t *\n\t * @param name - Name of the form.\n\t *\n\t * @returns The repository form.\n\t *\n\t * @throws If a matching form cannot be found.\n\t */\n\tprivate async getCachedRepositoryForm(\n\t\tname: string,\n\t\tparams?: FetchParams,\n\t): Promise<Form> {\n\t\tconst cachedRepository = await this.getCachedRepository(params);\n\t\tconst form = cachedRepository.forms[name];\n\n\t\tif (!form) {\n\t\t\tthrow new PrismicError(\n\t\t\t\t`Form with name \"${name}\" could not be found`,\n\t\t\t\tundefined,\n\t\t\t\tundefined,\n\t\t\t);\n\t\t}\n\n\t\treturn form;\n\t}\n\n\t/**\n\t * Returns the ref needed to query based on the client's current state. This\n\t * method may make a network request to fetch a ref or resolve the user's ref\n\t * thunk.\n\t *\n\t * If auto previews are enabled, the preview ref takes priority if available.\n\t *\n\t * The following strategies are used depending on the client's state:\n\t *\n\t * - If the user called `queryLatestContent`: Use the repository's master ref.\n\t *   The ref is cached for 5 seconds. After 5 seconds, a new master ref is\n\t *   fetched.\n\t * - If the user called `queryContentFromReleaseByID`: Use the release's ref.\n\t *   The ref is cached for 5 seconds. After 5 seconds, a new ref for the\n\t *   release is fetched.\n\t * - If the user called `queryContentFromReleaseByLabel`: Use the release's ref.\n\t *   The ref is cached for 5 seconds. After 5 seconds, a new ref for the\n\t *   release is fetched.\n\t * - If the user called `queryContentFromRef`: Use the provided ref. Fall back\n\t *   to the master ref if the ref is not a string.\n\t *\n\t * @returns The ref to use during a query.\n\t */\n\tprivate async getResolvedRefString(params?: FetchParams): Promise<string> {\n\t\tif (this.refState.autoPreviewsEnabled) {\n\t\t\tlet previewRef: string | undefined;\n\n\t\t\tlet cookieJar: string | null | undefined;\n\n\t\t\tif (this.refState.httpRequest?.headers) {\n\t\t\t\tif (\n\t\t\t\t\t\"get\" in this.refState.httpRequest.headers &&\n\t\t\t\t\ttypeof this.refState.httpRequest.headers.get === \"function\"\n\t\t\t\t) {\n\t\t\t\t\t// Web API Headers\n\t\t\t\t\tcookieJar = this.refState.httpRequest.headers.get(\"cookie\");\n\t\t\t\t} else if (\"cookie\" in this.refState.httpRequest.headers) {\n\t\t\t\t\t// Express-style headers\n\t\t\t\t\tcookieJar = this.refState.httpRequest.headers.cookie;\n\t\t\t\t}\n\t\t\t} else if (globalThis.document?.cookie) {\n\t\t\t\tcookieJar = globalThis.document.cookie;\n\t\t\t}\n\n\t\t\tif (cookieJar) {\n\t\t\t\tpreviewRef = getPreviewCookie(cookieJar);\n\t\t\t}\n\n\t\t\tif (previewRef) {\n\t\t\t\treturn previewRef;\n\t\t\t}\n\t\t}\n\n\t\tconst cachedRepository = await this.getCachedRepository(params);\n\n\t\tconst refModeType = this.refState.mode;\n\t\tif (refModeType === RefStateMode.ReleaseID) {\n\t\t\treturn findRefByID(cachedRepository.refs, this.refState.releaseID).ref;\n\t\t} else if (refModeType === RefStateMode.ReleaseLabel) {\n\t\t\treturn findRefByLabel(cachedRepository.refs, this.refState.releaseLabel)\n\t\t\t\t.ref;\n\t\t} else if (refModeType === RefStateMode.Manual) {\n\t\t\tconst res = await castThunk(this.refState.ref)();\n\n\t\t\tif (typeof res === \"string\") {\n\t\t\t\treturn res;\n\t\t\t}\n\t\t}\n\n\t\treturn findMasterRef(cachedRepository.refs).ref;\n\t}\n\n\t/**\n\t * Performs a network request using the configured `fetch` function. It\n\t * assumes all successful responses will have a JSON content type. It also\n\t * normalizes unsuccessful network requests.\n\t *\n\t * @typeParam T - The JSON response.\n\t *\n\t * @param url - URL to the resource to fetch.\n\t * @param params - Prismic REST API parameters for the network request.\n\t *\n\t * @returns The JSON response from the network request.\n\t */\n\tprivate async fetch<T = unknown>(\n\t\turl: string,\n\t\tparams: FetchParams = {},\n\t): Promise<T> {\n\t\tconst requestInit: RequestInitLike = {\n\t\t\t...this.fetchOptions,\n\t\t\t...params.fetchOptions,\n\t\t\theaders: {\n\t\t\t\t...this.fetchOptions?.headers,\n\t\t\t\t...params.fetchOptions?.headers,\n\t\t\t},\n\t\t\tsignal:\n\t\t\t\tparams.fetchOptions?.signal ||\n\t\t\t\tparams.signal ||\n\t\t\t\tthis.fetchOptions?.signal,\n\t\t};\n\n\t\tlet job: Promise<FetchJobResult>;\n\n\t\t// `fetchJobs` is keyed twice: first by the URL and again by is\n\t\t// signal, if one exists.\n\t\t//\n\t\t// Using two keys allows us to reuse fetch requests for\n\t\t// equivalent URLs, but eject when we detect unique signals.\n\t\tif (this.fetchJobs[url] && this.fetchJobs[url].has(requestInit.signal)) {\n\t\t\t// eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n\t\t\tjob = this.fetchJobs[url].get(requestInit.signal)!;\n\t\t} else {\n\t\t\tthis.fetchJobs[url] = this.fetchJobs[url] || new Map();\n\n\t\t\tjob = this.fetchFn(url, requestInit)\n\t\t\t\t.then(async (res) => {\n\t\t\t\t\t// We can assume Prismic REST API responses\n\t\t\t\t\t// will have a `application/json`\n\t\t\t\t\t// Content Type. If not, this will\n\t\t\t\t\t// throw, signaling an invalid\n\t\t\t\t\t// response.\n\t\t\t\t\t// eslint-disable-next-line @typescript-eslint/no-explicit-any\n\t\t\t\t\tlet json: any = undefined;\n\t\t\t\t\ttry {\n\t\t\t\t\t\tjson = await res.json();\n\t\t\t\t\t} catch {\n\t\t\t\t\t\t// noop\n\t\t\t\t\t}\n\n\t\t\t\t\treturn {\n\t\t\t\t\t\tstatus: res.status,\n\t\t\t\t\t\tjson,\n\t\t\t\t\t};\n\t\t\t\t})\n\t\t\t\t.finally(() => {\n\t\t\t\t\tthis.fetchJobs[url].delete(requestInit.signal);\n\n\t\t\t\t\tif (this.fetchJobs[url].size === 0) {\n\t\t\t\t\t\tdelete this.fetchJobs[url];\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\tthis.fetchJobs[url].set(requestInit.signal, job);\n\t\t}\n\n\t\tconst res = await job;\n\n\t\tif (res.status !== 404 && res.json == null) {\n\t\t\tthrow new PrismicError(undefined, url, res.json);\n\t\t}\n\n\t\tswitch (res.status) {\n\t\t\t// Successful\n\t\t\tcase 200: {\n\t\t\t\treturn res.json;\n\t\t\t}\n\n\t\t\t// Bad Request\n\t\t\t// - Invalid filter syntax\n\t\t\t// - Ref not provided (ignored)\n\t\t\tcase 400: {\n\t\t\t\tthrow new ParsingError(res.json.message, url, res.json);\n\t\t\t}\n\n\t\t\t// Unauthorized\n\t\t\t// - Missing access token for repository endpoint\n\t\t\t// - Incorrect access token for repository endpoint\n\t\t\tcase 401:\n\t\t\t// Forbidden\n\t\t\t// - Missing access token for query endpoint\n\t\t\t// - Incorrect access token for query endpoint\n\t\t\tcase 403: {\n\t\t\t\tthrow new ForbiddenError(\n\t\t\t\t\t\"error\" in res.json ? res.json.error : res.json.message,\n\t\t\t\t\turl,\n\t\t\t\t\tres.json,\n\t\t\t\t);\n\t\t\t}\n\n\t\t\t// Not Found (this response has an empty body)\n\t\t\t// - Incorrect repository name\n\t\t\tcase 404: {\n\t\t\t\tthrow new NotFoundError(\n\t\t\t\t\t`Prismic repository not found. Check that \"${this.endpoint}\" is pointing to the correct repository.`,\n\t\t\t\t\turl,\n\t\t\t\t\tundefined,\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\tthrow new PrismicError(undefined, url, res.json);\n\t}\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}